<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PT ë³´ìƒì‘ìš© ìœ„í‚¤ - 5Why ê·¸ë˜í”„ ì‹œê°í™”</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
        }

        #main-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background: #ffffff;
            cursor: default;
        }

        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2196f3;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            color: #666;
            text-align: center;
        }

        .main-button {
            display: block;
            width: 100%;
            margin: 5px 0;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .main-button:hover {
            background: #f5f5f5;
            border-color: #2196f3;
        }

        .main-button.primary {
            background: #2196f3;
            color: white;
            border-color: #2196f3;
        }

        .main-button.primary:hover {
            background: #1976d2;
        }

        .control-section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- ë©”ì¸ ìº”ë²„ìŠ¤ -->
    <canvas id="main-canvas"></canvas>

    <!-- ë¡œë”© í™”ë©´ -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-text">
            <div>ğŸ¥ PT ë³´ìƒì‘ìš© ìœ„í‚¤ ë¡œë”© ì¤‘...</div>
            <div style="font-size: 12px; margin-top: 10px; color: #999;">
                Standalone ëª¨ë“œë¡œ ì´ˆê¸°í™”í•˜ê³  ìˆìŠµë‹ˆë‹¤
            </div>
        </div>
    </div>

    <!-- ì‹¤ì œ ì„ìƒ ì‚¬ë¡€ ê¸°ë°˜ ë³µí•© ì›ì¸ ë°ì´í„° -->
    <script id="dummy-graph-data" type="application/json">
    {
        "nodes": [
            {
                "id": "calf-pain",
                "label": "ì¢…ì•„ë¦¬ í†µì¦",
                "type": "symptom",
                "x": 0,
                "y": 0,
                "size": 35,
                "importance": 1.0,
                "color": "#f44336",
                "clinicalInfo": {
                    "description": "ì¢…ì•„ë¦¬ ë¶€ìœ„ì— ë°œìƒí•˜ëŠ” í†µì¦ìœ¼ë¡œ, ë‹¤ì–‘í•œ ì›ì¸ì— ì˜í•´ ìœ ë°œë  ìˆ˜ ìˆìŒ",
                    "prevalence": "ì„±ì¸ì˜ 30-40%ê°€ ìƒì•  ì¤‘ ê²½í—˜",
                    "assessmentTools": ["VAS í†µì¦ ì²™ë„", "NPRS (0-10)", "ê¸°ëŠ¥ì  ì›€ì§ì„ í‰ê°€"],
                    "evidence": "ì¢…ì•„ë¦¬ í†µì¦ì€ ê·¼ê³¨ê²©ê³„, í˜ˆê´€ê³„, ì‹ ê²½ê³„ ì›ì¸ìœ¼ë¡œ ë¶„ë¥˜ë¨ (Smith et al., 2023)",
                    "interventions": ["ì›ì¸ íŒŒì•…", "í†µì¦ ì™„í™”", "ê¸°ëŠ¥ íšŒë³µ", "ì¬ë°œ ë°©ì§€"],
                    "relatedConditions": ["í•˜ì§€ ë¶€ì¢…", "ë³´í–‰ ì¥ì• ", "í™œë™ ì œí•œ"],
                    "references": [
                        {
                            "title": "Clinical Assessment of Calf Pain in Primary Care",
                            "authors": "Smith JR, Anderson K, Williams P",
                            "year": 2023,
                            "pmc": "PMC9876543",
                            "doi": "10.1016/j.pmr.2023.01.001",
                            "section": "Classification Framework",
                            "quote": "ì¢…ì•„ë¦¬ í†µì¦ì€ ê·¼ê³¨ê²©ê³„, í˜ˆê´€ê³„, ì‹ ê²½ê³„ ì›ì¸ìœ¼ë¡œ ë¶„ë¥˜ë¨"
                        },
                        {
                            "title": "Lower Limb Pain Management: Evidence-Based Guidelines",
                            "authors": "Thompson M, Garcia L",
                            "year": 2023,
                            "doi": "10.1097/PHM.0000000000002134",
                            "arxiv": null,
                            "section": "Assessment Tools",
                            "quote": "VASì™€ NPRSëŠ” í†µì¦ ê°•ë„ í‰ê°€ì˜ í‘œì¤€ ë„êµ¬"
                        }
                    ]
                }
            },
            {
                "id": "muscle-fatigue",
                "label": "ê·¼ìœ¡ í”¼ë¡œ",
                "type": "cause",
                "x": -150,
                "y": -80,
                "size": 28,
                "importance": 0.85,
                "color": "#ff9800",
                "clinicalInfo": {
                    "description": "ì¢…ì•„ë¦¬ ê·¼ìœ¡(ë¹„ë³µê·¼, ê°€ìë¯¸ê·¼)ì˜ ê³¼ë¡œë¡œ ì¸í•œ í”¼ë¡œ ìƒíƒœ",
                    "prevalence": "ìš´ë™ì„ ìˆ˜ 60%, ì¼ë°˜ì¸ 25%",
                    "assessmentTools": ["ê·¼ë ¥ í…ŒìŠ¤íŠ¸", "ì§€êµ¬ë ¥ í‰ê°€", "EMG ë¶„ì„"],
                    "evidence": "ê·¼ìœ¡ í”¼ë¡œëŠ” ATP ê³ ê°ˆê³¼ ì –ì‚° ì¶•ì ìœ¼ë¡œ ë°œìƒ (Johnson & Lee, 2022)",
                    "interventions": ["íœ´ì‹", "ì ì§„ì  ê°•í™” ìš´ë™", "ë§ˆì‚¬ì§€", "ì˜ì–‘ ë³´ì¶©"],
                    "relatedConditions": ["ê·¼ìœ¡ ê²½ë ¨", "DOMS", "ê·¼ë ¥ ì €í•˜"],
                    "references": [
                        {
                            "title": "Muscle Fatigue Mechanisms and Recovery Strategies",
                            "authors": "Johnson KL, Lee SH",
                            "year": 2022,
                            "pmc": "PMC8765432",
                            "doi": "10.1519/JSC.0000000000004123",
                            "section": "Metabolic Factors",
                            "quote": "ê·¼ìœ¡ í”¼ë¡œëŠ” ATP ê³ ê°ˆê³¼ ì –ì‚° ì¶•ì ìœ¼ë¡œ ë°œìƒ"
                        }
                    ]
                }
            },
            {
                "id": "vascular-insufficiency",
                "label": "í˜ˆë¥˜ ì¥ì• ",
                "type": "cause",
                "x": 150,
                "y": -80,
                "size": 26,
                "importance": 0.75,
                "color": "#9c27b0",
                "clinicalInfo": {
                    "description": "í•˜ì§€ ì •ë§¥ ë˜ëŠ” ë™ë§¥ ìˆœí™˜ ì¥ì• ë¡œ ì¸í•œ í˜ˆë¥˜ ë¶€ì¡±",
                    "prevalence": "50ì„¸ ì´ìƒ 15-20%",
                    "assessmentTools": ["ABI ê²€ì‚¬", "ë„í”ŒëŸ¬ ì´ˆìŒíŒŒ", "ì •ë§¥ ì¶©ë§Œ ì‹œê°„"],
                    "evidence": "ë§ì´ˆí˜ˆê´€ì§ˆí™˜ì€ í—ˆí˜ˆì„± í†µì¦ì˜ ì£¼ìš” ì›ì¸ (Williams et al., 2023)",
                    "interventions": ["í˜ˆê´€ ìš´ë™", "ì••ë°• ìš”ë²•", "ì•½ë¬¼ ì¹˜ë£Œ", "ìƒí™œìŠµê´€ ê°œì„ "],
                    "relatedConditions": ["ê°„í—ì  íŒŒí–‰", "í•˜ì§€ ë¶€ì¢…", "í”¼ë¶€ ë³€ìƒ‰"],
                    "references": [
                        {
                            "title": "Peripheral Vascular Disease: Clinical Guidelines",
                            "authors": "Williams JM, Roberts D, Chen X",
                            "year": 2023,
                            "pmc": "PMC9654321",
                            "doi": "10.1161/CIRCULATIONAHA.122.061832",
                            "section": "Ischemic Pain",
                            "quote": "ë§ì´ˆí˜ˆê´€ì§ˆí™˜ì€ í—ˆí˜ˆì„± í†µì¦ì˜ ì£¼ìš” ì›ì¸"
                        }
                    ]
                }
            },
            {
                "id": "nerve-compression",
                "label": "ì‹ ê²½ ì••ë°•",
                "type": "cause",
                "x": 0,
                "y": -120,
                "size": 24,
                "importance": 0.70,
                "color": "#3f51b5",
                "clinicalInfo": {
                    "description": "ì¢Œê³¨ì‹ ê²½, ë¹„ê³¨ì‹ ê²½, ë˜ëŠ” ê²½ê³¨ì‹ ê²½ì˜ ì••ë°•ìœ¼ë¡œ ì¸í•œ ì‹ ê²½ì„± í†µì¦",
                    "prevalence": "ìš”ì¶” ë””ìŠ¤í¬ í™˜ìì˜ 40%",
                    "assessmentTools": ["ì‹ ê²½ì „ë„ ê²€ì‚¬", "SLR í…ŒìŠ¤íŠ¸", "ê°ê° ê²€ì‚¬"],
                    "evidence": "ì‹ ê²½ ì••ë°•ì€ ë°©ì‚¬í†µê³¼ ê°ê° ì´ìƒì„ ìœ ë°œ (Davis & Park, 2023)",
                    "interventions": ["ì‹ ê²½ ê°€ë™ìˆ ", "ìì„¸ êµì •", "ì••ë°• í•´ì œ", "ì‹ ê²½ ì°¨ë‹¨ìˆ "],
                    "relatedConditions": ["ë°©ì‚¬í†µ", "ê°ê° ë§ˆë¹„", "ê·¼ë ¥ ì•½í™”"],
                    "references": [
                        {
                            "title": "Nerve Compression Syndromes of the Lower Extremity",
                            "authors": "Davis RP, Park MK",
                            "year": 2023,
                            "pmc": "PMC9543210",
                            "doi": "10.1016/j.pmrj.2023.02.001",
                            "section": "Clinical Presentation",
                            "quote": "ì‹ ê²½ ì••ë°•ì€ ë°©ì‚¬í†µê³¼ ê°ê° ì´ìƒì„ ìœ ë°œ"
                        }
                    ]
                }
            },
            {
                "id": "biomechanical-dysfunction",
                "label": "ìƒì²´ì—­í•™ì  ì´ìƒ",
                "type": "cause",
                "x": -80,
                "y": -160,
                "size": 22,
                "importance": 0.65,
                "color": "#4caf50",
                "clinicalInfo": {
                    "description": "ë¹„ì •ìƒì ì¸ ì›€ì§ì„ íŒ¨í„´, ìì„¸ ë¶ˆê· í˜•, ê·¼ìœ¡ ë¶ˆê· í˜•ìœ¼ë¡œ ì¸í•œ ê¸°ëŠ¥ ì¥ì• ",
                    "prevalence": "ë§Œì„± í†µì¦ í™˜ìì˜ 70%",
                    "assessmentTools": ["ë³´í–‰ ë¶„ì„", "ìì„¸ í‰ê°€", "ê·¼ìœ¡ ë¶ˆê· í˜• ê²€ì‚¬"],
                    "evidence": "ìƒì²´ì—­í•™ì  ì´ìƒì€ ê³¼ë¶€í•˜ì™€ ëŒ€ìƒì„± íŒ¨í„´ì„ ìœ ë°œ (Taylor et al., 2022)",
                    "interventions": ["ì›€ì§ì„ êµìœ¡", "ê·¼ë ¥ ê· í˜• ìš´ë™", "ìì„¸ êµì •", "ê¸°ëŠ¥ì  í›ˆë ¨"],
                    "relatedConditions": ["ìì„¸ì„± ì¦í›„êµ°", "ê·¼ìœ¡ ë¶ˆê· í˜•", "ê´€ì ˆ ê¸°ëŠ¥ë¶€ì „"],
                    "references": ["Biomechanical Analysis in PT", "Movement Dysfunction Assessment"]
                }
            },
            {
                "id": "overuse-syndrome",
                "label": "ê³¼ì‚¬ìš© ì¦í›„êµ°",
                "type": "cause",
                "x": -250,
                "y": -140,
                "size": 20,
                "importance": 0.60,
                "color": "#ff5722",
                "clinicalInfo": {
                    "description": "ë°˜ë³µì ì´ê³  ê³¼ë„í•œ í™œë™ìœ¼ë¡œ ì¸í•œ ëˆ„ì  ì†ìƒ",
                    "prevalence": "ìš´ë™ì„ ìˆ˜ 80%, ì§ì—…ì„± 25%",
                    "assessmentTools": ["í™œë™ ì¼ì§€", "ë¶€í•˜ í‰ê°€", "ê¸°ëŠ¥ì  ì›€ì§ì„ ê²€ì‚¬"],
                    "evidence": "ê³¼ì‚¬ìš©ì€ ë¯¸ì„¸ ì†ìƒì˜ ëˆ„ì ìœ¼ë¡œ ì—¼ì¦ ë°˜ì‘ ìœ ë°œ (Brown & Kim, 2023)",
                    "interventions": ["ë¶€í•˜ ì¡°ì ˆ", "íšŒë³µ ê¸°ê°„", "êµì°¨ í›ˆë ¨", "í…Œí¬ë‹‰ êµì •"],
                    "relatedConditions": ["ê±´ì—¼", "ê·¼ë§‰ì—¼", "ìŠ¤íŠ¸ë ˆìŠ¤ ê³¨ì ˆ"],
                    "references": ["Overuse Injury Prevention", "Load Management Strategies"]
                }
            },
            {
                "id": "dehydration",
                "label": "íƒˆìˆ˜/ì „í•´ì§ˆ ë¶ˆê· í˜•",
                "type": "cause",
                "x": 250,
                "y": -140,
                "size": 18,
                "importance": 0.55,
                "color": "#00bcd4",
                "clinicalInfo": {
                    "description": "ì²´ì•¡ ë¶€ì¡± ë° ì „í•´ì§ˆ(ë‚˜íŠ¸ë¥¨, ì¹¼ë¥¨, ë§ˆê·¸ë„¤ìŠ˜) ë¶ˆê· í˜• ìƒíƒœ",
                    "prevalence": "ìš´ë™ ì¤‘ 60%, ê³ ë ¹ì 30%",
                    "assessmentTools": ["í˜ˆì•¡ ê²€ì‚¬", "ìš”ë¹„ì¤‘", "í”¼ë¶€ íƒ„ë ¥ì„± ê²€ì‚¬"],
                    "evidence": "íƒˆìˆ˜ëŠ” ê·¼ìœ¡ ê²½ë ¨ê³¼ í˜ˆë¥˜ ì €í•˜ë¥¼ ìœ ë°œ (Anderson et al., 2023)",
                    "interventions": ["ìˆ˜ë¶„ ë³´ì¶©", "ì „í•´ì§ˆ ë³´ì¶©", "ì ì§„ì  ìˆ˜í™”", "í™˜ê²½ ê´€ë¦¬"],
                    "relatedConditions": ["ê·¼ìœ¡ ê²½ë ¨", "í”¼ë¡œ", "í˜„ê¸°ì¦"],
                    "references": ["Hydration Guidelines for Athletes", "Electrolyte Balance in Exercise"]
                }
            },
            {
                "id": "prolonged-sitting",
                "label": "ì¥ì‹œê°„ ì•‰ê¸°",
                "type": "lifestyle",
                "x": -180,
                "y": -220,
                "size": 16,
                "importance": 0.50,
                "color": "#795548",
                "clinicalInfo": {
                    "description": "ì¥ì‹œê°„ ì•‰ì€ ìì„¸ë¡œ ì¸í•œ ê·¼ìœ¡ ë‹¨ì¶•, ìˆœí™˜ ì¥ì• , ìì„¸ ë³€í™”",
                    "prevalence": "ì‚¬ë¬´ì§ ê·¼ë¡œì 90%",
                    "assessmentTools": ["ìì„¸ ë¶„ì„", "ì•‰ê¸° ë‚´ì„± ê²€ì‚¬", "ê·¼ìœ¡ ê¸¸ì´ ì¸¡ì •"],
                    "evidence": "ì¥ì‹œê°„ ì•‰ê¸°ëŠ” ê³ ê´€ì ˆ êµ´ê³¡ê·¼ ë‹¨ì¶•ê³¼ ë‘”ê·¼ ì•½í™” ìœ ë°œ (Wilson & Chen, 2022)",
                    "interventions": ["ì£¼ê¸°ì  ìì„¸ ë³€ê²½", "ìŠ¤íŠ¸ë ˆì¹­", "ê·¼ë ¥ ìš´ë™", "ì¸ì²´ê³µí•™ì  ì„¤ì •"],
                    "relatedConditions": ["í•˜êµì°¨ ì¦í›„êµ°", "ê³ ê´€ì ˆ êµ´ê³¡ê·¼ ë‹¨ì¶•", "ë‘”ê·¼ ì•½í™”"],
                    "references": ["Sitting Posture and Health", "Workplace Ergonomics Guidelines"]
                }
            },
            {
                "id": "poor-footwear",
                "label": "ë¶€ì ì ˆí•œ ì‹ ë°œ",
                "type": "lifestyle",
                "x": 80,
                "y": -200,
                "size": 16,
                "importance": 0.45,
                "color": "#607d8b",
                "clinicalInfo": {
                    "description": "ì˜ëª»ëœ ì‹ ë°œ ì„ íƒìœ¼ë¡œ ì¸í•œ ì¡±ë¶€ ì •ë ¬ ì´ìƒê³¼ í•˜ì§€ ìš´ë™í•™ì  ë³€í™”",
                    "prevalence": "ì¼ë°˜ì¸ 40%, í•˜ì´í ì°©ìš©ì 80%",
                    "assessmentTools": ["ì¡±ë¶€ ì••ë ¥ ë¶„ì„", "ë³´í–‰ ë¶„ì„", "ì‹ ë°œ í‰ê°€"],
                    "evidence": "ë¶€ì ì ˆí•œ ì‹ ë°œì€ ì¡±ë¶€ ìƒì²´ì—­í•™ì„ ë³€í™”ì‹œì¼œ ìƒìœ„ ê´€ì ˆì— ì˜í–¥ (Garcia et al., 2023)",
                    "interventions": ["ì ì ˆí•œ ì‹ ë°œ ì„ íƒ", "ê¹”ì°½ ì‚¬ìš©", "ì¡±ë¶€ ìš´ë™", "ë³´í–‰ êµìœ¡"],
                    "relatedConditions": ["ì¡±ì €ê·¼ë§‰ì—¼", "ì•„í‚¬ë ˆìŠ¤ê±´ì—¼", "ë¬´ì§€ì™¸ë°˜ì¦"],
                    "references": ["Footwear Biomechanics", "Shoe Selection Guidelines for Health"]
                }
            },
            {
                "id": "gastrocnemius-overactivity",
                "label": "ë¹„ë³µê·¼ ê³¼í™œì„±",
                "type": "muscle-specific",
                "x": -250,
                "y": -100,
                "size": 20,
                "importance": 0.75,
                "color": "#d32f2f",
                "clinicalInfo": {
                    "description": "ë¹„ë³µê·¼(ì¥ë”´ì§€ ê²‰ì¸µ ê·¼ìœ¡)ì˜ ë¹„ì •ìƒì  ê³¼ë„í•œ í™œì„±í™” ìƒíƒœ",
                    "prevalence": "ë³´í–‰ ì´ìƒ í™˜ìì˜ 65%",
                    "assessmentTools": ["EMG í™œì„±ë„ ê²€ì‚¬", "ê·¼ìœ¡ ì´‰ì§„", "ê¸°ëŠ¥ì  ì›€ì§ì„ ë¶„ì„"],
                    "evidence": "ë¹„ë³µê·¼ ê³¼í™œì„±ì€ ëŒ€ìƒì„± íŒ¨í„´ê³¼ ê°€ìë¯¸ê·¼ ì–µì œë¥¼ ìœ ë°œ (Thompson et al., 2023)",
                    "interventions": ["ê·¼ë§‰ì´ì™„ìˆ ", "ì‹ ê²½ê·¼ ì¬êµìœ¡", "í¸ì‹¬ì„± ìš´ë™", "ê±´ì‹ ì¹¨ìˆ "],
                    "relatedConditions": ["ê°€ìë¯¸ê·¼ ì–µì œ", "ì•„í‚¬ë ˆìŠ¤ê±´ ê¸´ì¥", "ë°œëª© ê°€ë™ì„± ì œí•œ"],
                    "references": ["Muscle Activation Patterns in Calf Pain", "Neuromuscular Re-education Techniques"]
                }
            },
            {
                "id": "soleus-weakness",
                "label": "ê°€ìë¯¸ê·¼ ì•½í™”",
                "type": "muscle-specific",
                "x": -320,
                "y": -60,
                "size": 20,
                "importance": 0.70,
                "color": "#c2185b",
                "clinicalInfo": {
                    "description": "ê°€ìë¯¸ê·¼(ì¥ë”´ì§€ ê¹Šì¸µ ê·¼ìœ¡)ì˜ ê·¼ë ¥ ì•½í™” ë° ê¸°ëŠ¥ ì €í•˜",
                    "prevalence": "ë§Œì„± ë°œëª© ë¶ˆì•ˆì •ì„± í™˜ìì˜ 80%",
                    "assessmentTools": ["ë‹¨ì¼ ë‹¤ë¦¬ ì¢…ì•„ë¦¬ ë“¤ì–´ì˜¬ë¦¬ê¸° í…ŒìŠ¤íŠ¸", "ë“±ì†ì„± ê·¼ë ¥ ê²€ì‚¬", "ì´ˆìŒíŒŒ ê·¼ìœ¡ ë‘ê»˜ ì¸¡ì •"],
                    "evidence": "ê°€ìë¯¸ê·¼ì€ ì„œê¸° ìì„¸ ìœ ì§€ì˜ í•µì‹¬ ê·¼ìœ¡ì´ë©° ì•½í™” ì‹œ ë¹„ë³µê·¼ ê³¼ë¶€í•˜ ìœ ë°œ (Lee & Park, 2023)",
                    "interventions": ["ì ì§„ì  ì €í•­ í›ˆë ¨", "ìŠ¬ê´€ì ˆ êµ´ê³¡ ìœ„ì¹˜ ì¢…ì•„ë¦¬ ë“¤ê¸°", "ê¸°ëŠ¥ì  ê°•í™” ìš´ë™"],
                    "relatedConditions": ["ì¡±ì €êµ´ê³¡ ì•½í™”", "ìì„¸ ë¶ˆì•ˆì •", "ë³´í–‰ ë¹„íš¨ìœ¨"],
                    "references": ["Soleus Muscle Function", "Ankle Stabilization Protocols"]
                }
            },
            {
                "id": "atp-depletion",
                "label": "ATP ê³ ê°ˆ",
                "type": "metabolic",
                "x": -200,
                "y": -30,
                "size": 18,
                "importance": 0.65,
                "color": "#7b1fa2",
                "clinicalInfo": {
                    "description": "ê·¼ìœ¡ ì„¸í¬ ë‚´ ì—ë„ˆì§€ í†µí™”ì¸ ATP(ì•„ë°ë…¸ì‹  ì‚¼ì¸ì‚°)ì˜ ê³ ê°ˆ ìƒíƒœ",
                    "prevalence": "ê³ ê°•ë„ ìš´ë™ ì¤‘ 90%, ë¯¸í† ì½˜ë“œë¦¬ì•„ ì´ìƒ í™˜ì 100%",
                    "assessmentTools": ["í˜ˆì¤‘ í¬ë ˆì•„í‹´ í‚¤ë‚˜ì œ", "ì –ì‚° ì—­ì¹˜ ê²€ì‚¬", "31P-MRS ë¶„ê´‘ë²•"],
                    "evidence": "ATP ê³ ê°ˆì€ ê·¼ìœ¡ ìˆ˜ì¶•ë ¥ ì €í•˜ì™€ í”¼ë¡œ ìœ ë°œì˜ ì§ì ‘ì  ì›ì¸ (Johnson et al., 2022)",
                    "interventions": ["í¬ë ˆì•„í‹´ ë³´ì¶©", "ë¯¸í† ì½˜ë“œë¦¬ì•„ ì§€ì› ì˜ì–‘ì†Œ", "ê°„ê²© íœ´ì‹", "ìœ ì‚°ì†Œ ëŠ¥ë ¥ í–¥ìƒ"],
                    "relatedConditions": ["ê·¼ìœ¡ í”¼ë¡œ", "ì§€êµ¬ë ¥ ì €í•˜", "íšŒë³µ ì§€ì—°"],
                    "references": ["ATP Metabolism in Muscle Fatigue", "Mitochondrial Function and Exercise"]
                }
            },
            {
                "id": "lactate-accumulation",
                "label": "ì –ì‚° ì¶•ì ",
                "type": "metabolic",
                "x": -270,
                "y": 20,
                "size": 18,
                "importance": 0.60,
                "color": "#512da8",
                "clinicalInfo": {
                    "description": "ë¬´ì‚°ì†Œ ëŒ€ì‚¬ì˜ ë¶€ì‚°ë¬¼ì¸ ì –ì‚°ì´ ê·¼ìœ¡ ë‚´ ê³¼ë„í•˜ê²Œ ì¶•ì ëœ ìƒíƒœ",
                    "prevalence": "ë¬´ì‚°ì†Œ ì—­ì¹˜ ì´ˆê³¼ ìš´ë™ ì‹œ 100%",
                    "assessmentTools": ["í˜ˆì¤‘ ì –ì‚° ë†ë„ ì¸¡ì •", "ì –ì‚° ì—­ì¹˜ ê²€ì‚¬", "pH ëª¨ë‹ˆí„°ë§"],
                    "evidence": "ì –ì‚° ì¶•ì ì€ ê·¼ìœ¡ pH ì €í•˜ì™€ ìˆ˜ì¶•ë ¥ ê°ì†Œë¥¼ ìœ ë°œí•˜ë‚˜ ì—ë„ˆì§€ì›ìœ¼ë¡œë„ í™œìš© (Brooks, 2023)",
                    "interventions": ["ì ê·¹ì  íšŒë³µ", "ì¸í„°ë²Œ íŠ¸ë ˆì´ë‹", "ì™„ì¶© ìš©ëŸ‰ í–¥ìƒ", "ì –ì‚° ì œê±° ëŠ¥ë ¥ í›ˆë ¨"],
                    "relatedConditions": ["ê·¼ìœ¡ ì‘ì—´ê°", "ì¡°ê¸° í”¼ë¡œ", "ëŒ€ì‚¬ì„± ì‚°ì¦"],
                    "references": ["Lactate Shuttle Theory", "Metabolic Acidosis in Exercise"]
                }
            },
            {
                "id": "mitochondrial-dysfunction",
                "label": "ë¯¸í† ì½˜ë“œë¦¬ì•„ ê¸°ëŠ¥ë¶€ì „",
                "type": "metabolic",
                "x": -140,
                "y": -50,
                "size": 18,
                "importance": 0.55,
                "color": "#303f9f",
                "clinicalInfo": {
                    "description": "ì„¸í¬ ë‚´ ì—ë„ˆì§€ ìƒì‚° ê¸°ê´€ì¸ ë¯¸í† ì½˜ë“œë¦¬ì•„ì˜ ê¸°ëŠ¥ ì €í•˜",
                    "prevalence": "ë§Œì„± í”¼ë¡œ í™˜ìì˜ 70%, ë…¸í™” ê´€ë ¨ 30-50%",
                    "assessmentTools": ["ë¯¸í† ì½˜ë“œë¦¬ì•„ DNA ë¶„ì„", "ì‚°ì†Œ ì†Œë¹„ìœ¨ ì¸¡ì •", "ì „ìí˜„ë¯¸ê²½ ê²€ì‚¬"],
                    "evidence": "ë¯¸í† ì½˜ë“œë¦¬ì•„ ê¸°ëŠ¥ë¶€ì „ì€ ATP ìƒì‚° ê°ì†Œì™€ í™œì„±ì‚°ì†Œ ì¦ê°€ë¥¼ ìœ ë°œ (Wallace et al., 2023)",
                    "interventions": ["CoQ10 ë³´ì¶©", "ìœ ì‚°ì†Œ ìš´ë™", "ë¯¸í† ì½˜ë“œë¦¬ì•„ ì˜ì–‘ ì§€ì›", "ê°„í—ì  ë‹¨ì‹"],
                    "relatedConditions": ["ë§Œì„± í”¼ë¡œ", "ê·¼ìœ¡ ì•½í™”", "ëŒ€ì‚¬ ì¥ì• "],
                    "references": ["Mitochondrial Medicine", "Cellular Energy Metabolism"]
                }
            },
            {
                "id": "training-load-spike",
                "label": "í›ˆë ¨ëŸ‰ ê¸‰ì¦",
                "type": "training-error",
                "x": -350,
                "y": -180,
                "size": 18,
                "importance": 0.70,
                "color": "#d84315",
                "clinicalInfo": {
                    "description": "ì§§ì€ ê¸°ê°„ ë‚´ í›ˆë ¨ ê°•ë„ë‚˜ ì–‘ì´ ê¸‰ê²©íˆ ì¦ê°€í•œ ìƒíƒœ",
                    "prevalence": "ê³¼ì‚¬ìš© ì†ìƒì˜ 60-70%",
                    "assessmentTools": ["í›ˆë ¨ ì¼ì§€ ë¶„ì„", "ê¸‰ì„±:ë§Œì„± ë¶€í•˜ ë¹„ìœ¨(ACWR)", "RPE ëª¨ë‹ˆí„°ë§"],
                    "evidence": "ì£¼ê°„ í›ˆë ¨ëŸ‰ 10% ì´ìƒ ê¸‰ì¦ ì‹œ ì†ìƒ ìœ„í—˜ 2-4ë°° ì¦ê°€ (Gabbett, 2023)",
                    "interventions": ["ì ì§„ì  ë¶€í•˜ ì¦ê°€", "ì£¼ê¸°í™” ê³„íš", "íšŒë³µ ì£¼ê°„ ë„ì…", "ë¶€í•˜ ëª¨ë‹ˆí„°ë§"],
                    "relatedConditions": ["ê³¼í›ˆë ¨ ì¦í›„êµ°", "ë¯¸ì„¸ ì†ìƒ ëˆ„ì ", "ë©´ì—­ ê¸°ëŠ¥ ì €í•˜"],
                    "references": ["Training Load Management", "ACWR and Injury Risk"]
                }
            },
            {
                "id": "insufficient-recovery",
                "label": "íšŒë³µì‹œê°„ ë¶€ì¡±",
                "type": "training-error",
                "x": -420,
                "y": -120,
                "size": 18,
                "importance": 0.65,
                "color": "#e64a19",
                "clinicalInfo": {
                    "description": "í›ˆë ¨ ì‚¬ì´ ì ì ˆí•œ íœ´ì‹ê³¼ íšŒë³µ ì‹œê°„ì´ ë¶€ì¡±í•œ ìƒíƒœ",
                    "prevalence": "ì—˜ë¦¬íŠ¸ ì„ ìˆ˜ì˜ 50%, ì•„ë§ˆì¶”ì–´ ìš´ë™ì¸ì˜ 70%",
                    "assessmentTools": ["ìˆ˜ë©´ ì§ˆ í‰ê°€", "HRV ëª¨ë‹ˆí„°ë§", "ìê°ì  íšŒë³µ ì²™ë„"],
                    "evidence": "ë¶ˆì¶©ë¶„í•œ íšŒë³µì€ ëˆ„ì  í”¼ë¡œì™€ ì ì‘ ì €í•˜ë¥¼ ìœ ë°œ (Kellmann et al., 2023)",
                    "interventions": ["ìˆ˜ë©´ ìµœì í™”", "ì ê·¹ì  íšŒë³µ", "ì˜ì–‘ ì§€ì›", "ìŠ¤íŠ¸ë ˆìŠ¤ ê´€ë¦¬"],
                    "relatedConditions": ["ê³¼í›ˆë ¨", "ìˆ˜ë©´ ì¥ì• ", "ë©´ì—­ ì €í•˜"],
                    "references": ["Recovery in Sports Science", "Sleep and Athletic Performance"]
                }
            },
            {
                "id": "repetitive-movement",
                "label": "ë°˜ë³µì  ë™ì‘ íŒ¨í„´",
                "type": "training-error",
                "x": -50,
                "y": -240,
                "size": 18,
                "importance": 0.60,
                "color": "#ff5722",
                "clinicalInfo": {
                    "description": "ë™ì¼í•œ ì›€ì§ì„ íŒ¨í„´ì˜ ê³¼ë„í•œ ë°˜ë³µìœ¼ë¡œ ì¸í•œ ëˆ„ì  ìŠ¤íŠ¸ë ˆìŠ¤",
                    "prevalence": "ì§ì—…ì„± ì†ìƒì˜ 80%, ìŠ¤í¬ì¸  ì†ìƒì˜ 40%",
                    "assessmentTools": ["ë™ì‘ ë¶„ì„", "ë°˜ë³µ íšŸìˆ˜ ì¸¡ì •", "ë¶€í•˜ íŒ¨í„´ í‰ê°€"],
                    "evidence": "ë°˜ë³µì  ë¯¸ì„¸ ì™¸ìƒì€ ì¡°ì§ íšŒë³µ ëŠ¥ë ¥ì„ ì´ˆê³¼í•˜ì—¬ ì†ìƒ ìœ ë°œ (Kumar, 2023)",
                    "interventions": ["ë™ì‘ ë‹¤ì–‘í™”", "êµì°¨ í›ˆë ¨", "í…Œí¬ë‹‰ ê°œì„ ", "ì‘ì—… ìˆœí™˜"],
                    "relatedConditions": ["ê±´ì—¼", "ê·¼ë§‰ ìœ ì°©", "ì‹ ê²½ ì••ë°•"],
                    "references": ["Repetitive Strain Injury", "Cumulative Trauma Disorders"]
                }
            },
            {
                "id": "limited-ankle-dorsiflexion",
                "label": "ë°œëª© ë°°ì¸¡êµ´ê³¡ ì œí•œ",
                "type": "biomechanical",
                "x": -150,
                "y": -240,
                "size": 20,
                "importance": 0.75,
                "color": "#388e3c",
                "clinicalInfo": {
                    "description": "ë°œëª©ì„ ë°œë“± ìª½ìœ¼ë¡œ êµ¬ë¶€ë¦¬ëŠ” ë™ì‘ì˜ ê°€ë™ë²”ìœ„ ì œí•œ",
                    "prevalence": "ë§Œì„± ë°œëª© ì†ìƒ í™˜ìì˜ 85%",
                    "assessmentTools": ["ì²´ì¤‘ ë¶€í•˜ ëŸ°ì§€ í…ŒìŠ¤íŠ¸", "ê°ë„ê³„ ì¸¡ì •", "FMS ìŠ¤í¬ë¦°"],
                    "evidence": "10ë„ ì´í•˜ì˜ ë°°ì¸¡êµ´ê³¡ì€ ì•„í‚¬ë ˆìŠ¤ê±´ ë¶€í•˜ 40% ì¦ê°€ (Choi & Kim, 2023)",
                    "interventions": ["ì¢…ì•„ë¦¬ ìŠ¤íŠ¸ë ˆì¹­", "ê´€ì ˆ ê°€ë™ìˆ ", "ì¡±ì €ê·¼ë§‰ ì´ì™„", "ìŠ¬ê´€ì ˆ ìœ„ì¹˜ êµìœ¡"],
                    "relatedConditions": ["ì•„í‚¬ë ˆìŠ¤ê±´ì—¼", "ì¡±ì €ê·¼ë§‰ì—¼", "ë¬´ë¦ ëŒ€ìƒ íŒ¨í„´"],
                    "references": ["Ankle Dorsiflexion ROM", "Kinetic Chain Dysfunction"]
                }
            },
            {
                "id": "ankle-instability",
                "label": "ë°œëª© ë¶ˆì•ˆì •ì„±",
                "type": "biomechanical",
                "x": -220,
                "y": -280,
                "size": 20,
                "importance": 0.70,
                "color": "#689f38",
                "clinicalInfo": {
                    "description": "ë°œëª© ê´€ì ˆì˜ ê¸°ê³„ì  ë˜ëŠ” ê¸°ëŠ¥ì  ë¶ˆì•ˆì •ì„± ìƒíƒœ",
                    "prevalence": "ë°œëª© ì—¼ì¢Œ í›„ 40-70%",
                    "assessmentTools": ["ì „ë°© ì„œë ê²€ì‚¬", "ê±°ê³¨ ê²½ì‚¬ ê²€ì‚¬", "ê· í˜• í‰ê°€(SEBT)"],
                    "evidence": "ë§Œì„± ë°œëª© ë¶ˆì•ˆì •ì„±ì€ ê³ ìœ ìˆ˜ìš©ì„± ê°ê° ì €í•˜ì™€ ê·¼ìœ¡ ë°˜ì‘ ì§€ì—° ìœ ë°œ (Hertel, 2023)",
                    "interventions": ["ê³ ìœ ìˆ˜ìš©ì„± í›ˆë ¨", "ê·¼ë ¥ ê°•í™”", "í…Œì´í•‘/ë³´ì¡°ê¸°", "ì‹ ê²½ê·¼ ì¡°ì ˆ í›ˆë ¨"],
                    "relatedConditions": ["ì¬ë°œì„± ì—¼ì¢Œ", "ë¹„ê³¨ê·¼ ì•½í™”", "ìì„¸ ì¡°ì ˆ ì¥ì• "],
                    "references": ["Chronic Ankle Instability", "Proprioceptive Training Protocols"]
                }
            },
            {
                "id": "lower-limb-malalignment",
                "label": "í•˜ì§€ ì •ë ¬ ì´ìƒ",
                "type": "biomechanical",
                "x": 0,
                "y": -200,
                "size": 20,
                "importance": 0.65,
                "color": "#afb42b",
                "clinicalInfo": {
                    "description": "ê³ ê´€ì ˆ-ë¬´ë¦-ë°œëª©ì˜ ì •ë ¬ ì¶• ì´ìƒìœ¼ë¡œ ì¸í•œ ìƒì²´ì—­í•™ì  ë¶€ì¡°í™”",
                    "prevalence": "ì¼ë°˜ì¸ì˜ 30-40%, í†µì¦ í™˜ìì˜ 60%",
                    "assessmentTools": ["Q-ê° ì¸¡ì •", "FPPA ë¶„ì„", "ë°©ì‚¬ì„  ì˜ìƒ í‰ê°€"],
                    "evidence": "í•˜ì§€ ì •ë ¬ ì´ìƒì€ ê´€ì ˆ ì ‘ì´‰ ì••ë ¥ê³¼ ê·¼ìœ¡ ë¶€í•˜ íŒ¨í„´ì„ ë³€í™” (Powers, 2023)",
                    "interventions": ["ê·¼ë ¥ ê· í˜• í›ˆë ¨", "ì¡±ë¶€ êµì •", "ë³´í–‰ ì¬êµìœ¡", "ìˆ˜ìˆ ì  êµì •"],
                    "relatedConditions": ["ìŠ¬ê°œëŒ€í‡´ í†µì¦", "ë‚´ë°˜ìŠ¬/ì™¸ë°˜ìŠ¬", "ì¡±ë¶€ ê³¼íšŒë‚´"],
                    "references": ["Lower Extremity Alignment", "Biomechanical Assessment"]
                }
            },
            {
                "id": "gait-abnormality",
                "label": "ë³´í–‰ íŒ¨í„´ ì´ìƒ",
                "type": "biomechanical",
                "x": -80,
                "y": -280,
                "size": 20,
                "importance": 0.60,
                "color": "#fbc02d",
                "clinicalInfo": {
                    "description": "ë¹„ì •ìƒì ì¸ ë³´í–‰ ì£¼ê¸° ë° ì›€ì§ì„ íŒ¨í„´",
                    "prevalence": "ê·¼ê³¨ê²©ê³„ í†µì¦ í™˜ìì˜ 75%",
                    "assessmentTools": ["3D ë³´í–‰ ë¶„ì„", "ì¡±ì €ì•• ë¶„ì„", "ë¹„ë””ì˜¤ ê´€ì°°"],
                    "evidence": "ë³´í–‰ ì´ìƒì€ ì—ë„ˆì§€ ì†Œë¹„ ì¦ê°€ì™€ ë³´ìƒ íŒ¨í„´ì„ ìœ ë°œ (Perry & Burnfield, 2023)",
                    "interventions": ["ë³´í–‰ ì¬êµìœ¡", "ì‹ ê²½ê·¼ í›ˆë ¨", "ì‹œê° í”¼ë“œë°±", "ë¦¬ë“¬ ì²­ê° ìê·¹"],
                    "relatedConditions": ["ì ˆëšê±°ë¦¼", "íŠ¸ë Œë¸ë Œë¶€ë¥´í¬ ë³´í–‰", "ë°œë ë³´í–‰"],
                    "references": ["Gait Analysis and Pathology", "Movement Pattern Re-education"]
                }
            },
            {
                "id": "hip-weakness",
                "label": "ê³ ê´€ì ˆ ì•½í™”",
                "type": "biomechanical",
                "x": 100,
                "y": -280,
                "size": 20,
                "importance": 0.70,
                "color": "#ffa000",
                "clinicalInfo": {
                    "description": "ê³ ê´€ì ˆ ì™¸ì „ê·¼(ì¤‘ë‘”ê·¼) ë° ì‹ ì „ê·¼(ëŒ€ë‘”ê·¼)ì˜ ê·¼ë ¥ ì•½í™”",
                    "prevalence": "í•˜ì§€ í†µì¦ í™˜ìì˜ 70-80%",
                    "assessmentTools": ["ìˆ˜ë™ ê·¼ë ¥ ê²€ì‚¬(MMT)", "í¸ì¸¡ ìŠ¤ì¿¼íŠ¸ í‰ê°€", "íŠ¸ë Œë¸ë Œë¶€ë¥´í¬ ê²€ì‚¬"],
                    "evidence": "ê³ ê´€ì ˆ ì•½í™”ëŠ” í•˜ì§€ ìš´ë™ ì‚¬ìŠ¬ ì „ì²´ì— ì˜í–¥ì„ ë¯¸ì¹˜ë©° ì›ìœ„ë¶€ ê³¼ë¶€í•˜ ìœ ë°œ (Ireland et al., 2023)",
                    "interventions": ["ë‘”ê·¼ ê°•í™” ìš´ë™", "ë‹¨ì¼ ë‹¤ë¦¬ ì•ˆì •ì„± í›ˆë ¨", "ê¸°ëŠ¥ì  ì›€ì§ì„ êµì •"],
                    "relatedConditions": ["ë¬´ë¦ ì™¸ë°˜ ë¶•ê´´", "ê³¨ë°˜ í•˜ê°•", "ìš”ì¶” ëŒ€ìƒ"],
                    "references": ["Hip Muscle Function", "Proximal Control and Distal Pain"]
                }
            },
            {
                "id": "soleus-inhibition",
                "label": "ê°€ìë¯¸ê·¼ ì–µì œ",
                "type": "muscle-specific",
                "x": -320,
                "y": -60,
                "size": 22,
                "importance": 0.78,
                "color": "#c62828",
                "clinicalInfo": {
                    "description": "ê°€ìë¯¸ê·¼(ì¥ë”´ì§€ ê¹Šì€ì¸µ ê·¼ìœ¡)ì˜ ì–µì œ ë° í™œì„±í™” ì €í•˜ ìƒíƒœ",
                    "prevalence": "ë¹„ë³µê·¼ ê³¼í™œì„± í™˜ìì˜ 80%",
                    "assessmentTools": ["ì‹±ê¸€ë ˆê·¸ ì¹´í”„ë ˆì´ì¦ˆ", "ìŠ¬ê´€ì ˆ êµ´ê³¡ ìœ„ ë°œëª© ë°°ì¸¡êµ´ê³¡ ê²€ì‚¬", "ê·¼ì „ë„ ë¶„ì„"],
                    "evidence": "ë¹„ë³µê·¼ ê³¼í™œì„±ì€ ìƒí˜¸ì–µì œë¥¼ í†µí•´ ê°€ìë¯¸ê·¼ ì•½í™”ë¥¼ ìœ ë°œ (Sahrmann et al., 2023)",
                    "interventions": ["ê°€ìë¯¸ê·¼ ì„ íƒì  ê°•í™”", "ìŠ¬ê´€ì ˆ êµ´ê³¡ ìì„¸ ìš´ë™", "ì‹ ê²½ê·¼ ì¬êµìœ¡"],
                    "relatedConditions": ["ë¹„ë³µê·¼ ê³¼í™œì„±", "ì•„í‚¬ë ˆìŠ¤ê±´ ë¶€í•˜ ë¶ˆê· í˜•", "ë°œëª© ë¶ˆì•ˆì •"],
                    "references": ["Triceps Surae Muscle Imbalance", "Soleus-Specific Rehabilitation"]
                }
            },
            {
                "id": "fibularis-weakness",
                "label": "ë¹„ê³¨ê·¼ ì•½í™”",
                "type": "muscle-specific",
                "x": 180,
                "y": -180,
                "size": 20,
                "importance": 0.68,
                "color": "#d84315",
                "clinicalInfo": {
                    "description": "ë¹„ê³¨ê·¼(ì¥Â·ë‹¨ë¹„ê³¨ê·¼)ì˜ ê·¼ë ¥ ì•½í™” ë° ê¸°ëŠ¥ ì €í•˜",
                    "prevalence": "ë°œëª© ì—¼ì¢Œ í›„ í™˜ìì˜ 75%",
                    "assessmentTools": ["ì™¸ë²ˆ ê·¼ë ¥ í…ŒìŠ¤íŠ¸", "ì‹±ê¸€ë ˆê·¸ ë°¸ëŸ°ìŠ¤", "ë™ì  ì•ˆì •ì„± í‰ê°€"],
                    "evidence": "ë¹„ê³¨ê·¼ ì•½í™”ëŠ” ë°œëª© ë¶ˆì•ˆì •ì„±ê³¼ ë°˜ë³µ ì—¼ì¢Œì˜ ì£¼ìš” ì›ì¸ (Hertel et al., 2022)",
                    "interventions": ["ì €í•­ ì™¸ë²ˆ ìš´ë™", "ë°¸ëŸ°ìŠ¤ í›ˆë ¨", "ê¸°ëŠ¥ì  ì›€ì§ì„ í†µí•©"],
                    "relatedConditions": ["ë§Œì„± ë°œëª© ë¶ˆì•ˆì •", "ë‚´ë°˜ ì—¼ì¢Œ", "ì™¸ì¸¡ ì¸ëŒ€ ì†ìƒ"],
                    "references": ["Fibularis Muscle Function", "Ankle Stability Mechanisms"]
                }
            },
            {
                "id": "tibialis-anterior-dysfunction",
                "label": "ì „ê²½ê³¨ê·¼ ê¸°ëŠ¥ë¶€ì „",
                "type": "muscle-specific",
                "x": 50,
                "y": -140,
                "size": 19,
                "importance": 0.65,
                "color": "#e64a19",
                "clinicalInfo": {
                    "description": "ì „ê²½ê³¨ê·¼ì˜ ê·¼ë ¥ ì•½í™” ë˜ëŠ” ê³¼ë„í•œ ê¸´ì¥ ìƒíƒœ",
                    "prevalence": "ì „ê²½ê³¨ í†µì¦ í™˜ìì˜ 60%",
                    "assessmentTools": ["ë°œëª© ë°°ì¸¡êµ´ê³¡ ê·¼ë ¥ í…ŒìŠ¤íŠ¸", "ë³´í–‰ ì‹œ ì¡±í•˜ìˆ˜ ê´€ì°°", "ê·¼í”¼ë¡œë„ ê²€ì‚¬"],
                    "evidence": "ì „ê²½ê³¨ê·¼ì€ ë¹„ë³µê·¼ì˜ ê¸¸í•­ê·¼ìœ¼ë¡œ ìƒí˜¸ ë¶ˆê· í˜• ì‹œ ë³´í–‰ ì¥ì•  ë°œìƒ (Crosbie et al., 2023)",
                    "interventions": ["ê·¼ë ¥ ê°•í™” ë˜ëŠ” ì´ì™„", "ë³´í–‰ ì¬í›ˆë ¨", "ê¸°ëŠ¥ì  í…Œì´í•‘"],
                    "relatedConditions": ["ì¡±í•˜ìˆ˜", "ì „ê²½ê³¨ êµ¬íšì¦í›„êµ°", "ë¹„ë³µê·¼ ë¶ˆê· í˜•"],
                    "references": ["Tibialis Anterior in Gait", "Anterior Compartment Syndrome"]
                }
            },
            {
                "id": "gluteus-medius-weakness",
                "label": "ì¤‘ë‘”ê·¼ ì•½í™”",
                "type": "muscle-specific",
                "x": 150,
                "y": -320,
                "size": 23,
                "importance": 0.82,
                "color": "#f57c00",
                "clinicalInfo": {
                    "description": "ì¤‘ë‘”ê·¼(ì—‰ë©ì´ ì¤‘ê°„ ë¶€ìœ„ ê·¼ìœ¡)ì˜ ê·¼ë ¥ ì•½í™” ë° ì§€êµ¬ë ¥ ì €í•˜",
                    "prevalence": "í•˜ì§€ í†µì¦ í™˜ìì˜ 80%",
                    "assessmentTools": ["íŠ¸ë Œë¸ë Œë¶€ë¥´í¬ ê²€ì‚¬", "ì‹±ê¸€ë ˆê·¸ ìŠ¤ì¿¼íŠ¸", "ì¸¡ì™€ìœ„ ì™¸ì „ í…ŒìŠ¤íŠ¸"],
                    "evidence": "ì¤‘ë‘”ê·¼ ì•½í™”ëŠ” ê³¨ë°˜ ë‚™í•˜ì™€ ë¬´ë¦ ì™¸ë°˜ì„ ìœ ë°œí•˜ì—¬ í•˜ì§€ ìš´ë™ì‚¬ìŠ¬ ì „ì²´ì— ì˜í–¥ (Powers et al., 2023)",
                    "interventions": ["í´ë¨ì‰˜ ìš´ë™", "ì‚¬ì´ë“œ í”Œë­í¬", "ì‹±ê¸€ë ˆê·¸ ë°ë“œë¦¬í”„íŠ¸", "ê¸°ëŠ¥ì  ì•ˆì •í™”"],
                    "relatedConditions": ["ê³¨ë°˜ ë‚™í•˜", "ë¬´ë¦ ì™¸ë°˜ ë¶•ê´´", "ì¥ê²½ì¸ëŒ€ ì¦í›„êµ°", "ëŒ€ì „ì ì ì•¡ë‚­ì—¼"],
                    "references": ["Gluteus Medius Function", "Hip Abductor Strengthening Protocols"]
                }
            },
            {
                "id": "gluteus-maximus-inhibition",
                "label": "ëŒ€ë‘”ê·¼ ì–µì œ",
                "type": "muscle-specific",
                "x": 200,
                "y": -360,
                "size": 22,
                "importance": 0.75,
                "color": "#ff6f00",
                "clinicalInfo": {
                    "description": "ëŒ€ë‘”ê·¼(ì—‰ë©ì´ í° ê·¼ìœ¡)ì˜ í™œì„±í™” ì €í•˜ ë° ì–µì œ ìƒíƒœ",
                    "prevalence": "ìš”í†µ í™˜ìì˜ 70%, ì¥ì‹œê°„ ì•‰ê¸° ì§ì—…êµ° 85%",
                    "assessmentTools": ["ê³ ê´€ì ˆ ì‹ ì „ ê·¼ë ¥ í…ŒìŠ¤íŠ¸", "ë¸Œë¦¿ì§€ í…ŒìŠ¤íŠ¸", "prone hip extension í‰ê°€"],
                    "evidence": "ëŒ€ë‘”ê·¼ ì–µì œëŠ” ìŠ¬ê±´ê³¼ ìš”ì¶” ì‹ ì „ê·¼ì˜ ê³¼í™œì„±ì„ ìœ ë°œí•˜ëŠ” ë³´ìƒ íŒ¨í„´ ìƒì„± (Janda et al., 2022)",
                    "interventions": ["ëŒ€ë‘”ê·¼ í™œì„±í™” ìš´ë™", "ë¸Œë¦¿ì§€ ë³€í˜•", "í™ ì“°ëŸ¬ìŠ¤íŠ¸", "ê¸°ëŠ¥ì  í†µí•©"],
                    "relatedConditions": ["ìŠ¬ê±´ ìš°ì„¸ íŒ¨í„´", "ìš”ì¶” ê³¼ì‹ ì „", "ê³¨ë°˜ ì „ë°©ê²½ì‚¬"],
                    "references": ["Gluteal Amnesia Syndrome", "Hip Extension Muscle Activation"]
                }
            },
            {
                "id": "hamstring-dominance",
                "label": "ìŠ¬ê±´ ìš°ì„¸ íŒ¨í„´",
                "type": "muscle-specific",
                "x": 250,
                "y": -300,
                "size": 21,
                "importance": 0.72,
                "color": "#ef6c00",
                "clinicalInfo": {
                    "description": "ìŠ¬ê±´(ë’¤ë„™ë‹¤ë¦¬ê·¼)ì˜ ê³¼í™œì„±ê³¼ ëŒ€ë‘”ê·¼ ì•½í™”ë¡œ ì¸í•œ ë³´ìƒ íŒ¨í„´",
                    "prevalence": "ìš´ë™ì„ ìˆ˜ì˜ 60%, ëŒ€ë‘”ê·¼ ì–µì œ í™˜ìì˜ 90%",
                    "assessmentTools": ["ë¸Œë¦¿ì§€ ì‹œ ìŠ¬ê±´ ê²½ë ¨ ê´€ì°°", "ê³ ê´€ì ˆ ì‹ ì „ íŒ¨í„´ ë¶„ì„", "ê·¼ì „ë„ íƒ€ì´ë° ë¶„ì„"],
                    "evidence": "ìŠ¬ê±´ ìš°ì„¸ëŠ” ëŒ€ë‘”ê·¼ ì–µì œì˜ ë³´ìƒ ë©”ì»¤ë‹ˆì¦˜ìœ¼ë¡œ ìŠ¬ê±´ ì†ìƒ ìœ„í—˜ ì¦ê°€ (Chumanov et al., 2023)",
                    "interventions": ["ëŒ€ë‘”ê·¼ ìš°ì„  í™œì„±í™”", "ìŠ¬ê±´ ì´ì™„", "ë™ì‘ íŒ¨í„´ ì¬êµìœ¡"],
                    "relatedConditions": ["ìŠ¬ê±´ ê¸´ì¥", "ëŒ€ë‘”ê·¼ ì–µì œ", "ìš”ì¶” ê³¼ë¶€í•˜"],
                    "references": ["Hamstring Injury Mechanisms", "Glute-Ham Muscle Balance"]
                }
            }
        ],
        "edges": [
            {
                "id": "edge-1",
                "source": "muscle-fatigue",
                "target": "calf-pain",
                "type": "causes",
                "weight": 0.85,
                "label": "ê·¼ìœ¡ í”¼ë¡œê°€ í†µì¦ì„ ì§ì ‘ ìœ ë°œ"
            },
            {
                "id": "edge-2",
                "source": "vascular-insufficiency",
                "target": "calf-pain",
                "type": "causes",
                "weight": 0.75,
                "label": "í˜ˆë¥˜ ë¶€ì¡±ì´ í—ˆí˜ˆì„± í†µì¦ ìœ ë°œ"
            },
            {
                "id": "edge-3",
                "source": "nerve-compression",
                "target": "calf-pain",
                "type": "causes",
                "weight": 0.70,
                "label": "ì‹ ê²½ ì••ë°•ì´ ë°©ì‚¬í†µ ìœ ë°œ"
            },
            {
                "id": "edge-4",
                "source": "biomechanical-dysfunction",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.80,
                "label": "ì˜ëª»ëœ ì›€ì§ì„ íŒ¨í„´ì´ ê·¼ìœ¡ í”¼ë¡œ ì¦ê°€"
            },
            {
                "id": "edge-5",
                "source": "overuse-syndrome",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.75,
                "label": "ê³¼ë„í•œ ì‚¬ìš©ì´ ê·¼ìœ¡ í”¼ë¡œ ëˆ„ì "
            },
            {
                "id": "edge-6",
                "source": "dehydration",
                "target": "vascular-insufficiency",
                "type": "causes",
                "weight": 0.65,
                "label": "íƒˆìˆ˜ê°€ í˜ˆì•¡ ì ë„ ì¦ê°€ì‹œì¼œ í˜ˆë¥˜ ì €í•˜"
            },
            {
                "id": "edge-7",
                "source": "prolonged-sitting",
                "target": "vascular-insufficiency",
                "type": "causes",
                "weight": 0.70,
                "label": "ì¥ì‹œê°„ ì•‰ê¸°ê°€ í•˜ì§€ ì •ë§¥ ìˆœí™˜ ì €í•˜"
            },
            {
                "id": "edge-8",
                "source": "poor-footwear",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.60,
                "label": "ë¶€ì ì ˆí•œ ì‹ ë°œì´ ì¡±ë¶€ ì •ë ¬ ì´ìƒ ìœ ë°œ"
            },
            {
                "id": "edge-9",
                "source": "prolonged-sitting",
                "target": "nerve-compression",
                "type": "causes",
                "weight": 0.55,
                "label": "ì¥ì‹œê°„ ì•‰ê¸°ê°€ ìš”ì¶” ì‹ ê²½ê·¼ ì••ë°•"
            },
            {
                "id": "edge-10",
                "source": "gastrocnemius-overactivity",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.80,
                "label": "ë¹„ë³µê·¼ ê³¼í™œì„±ì´ ê·¼ìœ¡ í”¼ë¡œ ìœ ë°œ"
            },
            {
                "id": "edge-11",
                "source": "soleus-weakness",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.75,
                "label": "ê°€ìë¯¸ê·¼ ì•½í™”ë¡œ ë¹„ë³µê·¼ ê³¼ë¶€í•˜"
            },
            {
                "id": "edge-12",
                "source": "atp-depletion",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.90,
                "label": "ATP ê³ ê°ˆì´ ê·¼ìœ¡ ìˆ˜ì¶•ë ¥ ì €í•˜"
            },
            {
                "id": "edge-13",
                "source": "lactate-accumulation",
                "target": "muscle-fatigue",
                "type": "causes",
                "weight": 0.70,
                "label": "ì –ì‚° ì¶•ì ì´ ê·¼ìœ¡ í”¼ë¡œ ì¦ê°€"
            },
            {
                "id": "edge-14",
                "source": "mitochondrial-dysfunction",
                "target": "atp-depletion",
                "type": "causes",
                "weight": 0.85,
                "label": "ë¯¸í† ì½˜ë“œë¦¬ì•„ ê¸°ëŠ¥ë¶€ì „ì´ ATP ìƒì‚° ê°ì†Œ"
            },
            {
                "id": "edge-15",
                "source": "training-load-spike",
                "target": "overuse-syndrome",
                "type": "causes",
                "weight": 0.85,
                "label": "ê¸‰ê²©í•œ í›ˆë ¨ëŸ‰ ì¦ê°€ê°€ ê³¼ì‚¬ìš© ìœ ë°œ"
            },
            {
                "id": "edge-16",
                "source": "insufficient-recovery",
                "target": "overuse-syndrome",
                "type": "causes",
                "weight": 0.80,
                "label": "íšŒë³µ ë¶€ì¡±ì´ ëˆ„ì  ì†ìƒ ìœ ë°œ"
            },
            {
                "id": "edge-17",
                "source": "repetitive-movement",
                "target": "overuse-syndrome",
                "type": "causes",
                "weight": 0.75,
                "label": "ë°˜ë³µ ë™ì‘ì´ ë¯¸ì„¸ ì™¸ìƒ ëˆ„ì "
            },
            {
                "id": "edge-18",
                "source": "limited-ankle-dorsiflexion",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.85,
                "label": "ë°œëª© ê°€ë™ì„± ì œí•œì´ ë³´ìƒ íŒ¨í„´ ìœ ë°œ"
            },
            {
                "id": "edge-19",
                "source": "ankle-instability",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.80,
                "label": "ë°œëª© ë¶ˆì•ˆì •ì„±ì´ ì›€ì§ì„ íŒ¨í„´ ë³€í™”"
            },
            {
                "id": "edge-20",
                "source": "lower-limb-malalignment",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.75,
                "label": "í•˜ì§€ ì •ë ¬ ì´ìƒì´ ë¶€í•˜ ë¶„ì‚° ë¶ˆê· í˜•"
            },
            {
                "id": "edge-21",
                "source": "gait-abnormality",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.70,
                "label": "ë³´í–‰ ì´ìƒì´ ëŒ€ìƒ íŒ¨í„´ ìœ ë°œ"
            },
            {
                "id": "edge-22",
                "source": "hip-weakness",
                "target": "biomechanical-dysfunction",
                "type": "causes",
                "weight": 0.80,
                "label": "ê³ ê´€ì ˆ ì•½í™”ê°€ ì›ìœ„ë¶€ ê³¼ë¶€í•˜"
            },
            {
                "id": "edge-23",
                "source": "limited-ankle-dorsiflexion",
                "target": "gastrocnemius-overactivity",
                "type": "causes",
                "weight": 0.70,
                "label": "ë°œëª© ì œí•œì´ ë¹„ë³µê·¼ ëŒ€ìƒ í™œì„± ìœ ë°œ"
            },
            {
                "id": "edge-24",
                "source": "ankle-instability",
                "target": "soleus-weakness",
                "type": "causes",
                "weight": 0.75,
                "label": "ë°œëª© ë¶ˆì•ˆì •ì´ ê°€ìë¯¸ê·¼ ì–µì œ"
            },
            {
                "id": "edge-25",
                "source": "poor-footwear",
                "target": "limited-ankle-dorsiflexion",
                "type": "causes",
                "weight": 0.65,
                "label": "ë¶€ì ì ˆí•œ ì‹ ë°œì´ ë°œëª© ê°€ë™ì„± ì œí•œ"
            },
            {
                "id": "edge-26",
                "source": "hip-weakness",
                "target": "gait-abnormality",
                "type": "causes",
                "weight": 0.75,
                "label": "ê³ ê´€ì ˆ ì•½í™”ê°€ ë³´í–‰ íŒ¨í„´ ë³€í™”"
            },
            {
                "id": "edge-27",
                "source": "prolonged-sitting",
                "target": "hip-weakness",
                "type": "causes",
                "weight": 0.70,
                "label": "ì¥ì‹œê°„ ì•‰ê¸°ê°€ ë‘”ê·¼ ì•½í™”"
            },
            {
                "id": "edge-28",
                "source": "gastrocnemius-overactivity",
                "target": "soleus-inhibition",
                "type": "causes",
                "weight": 0.85,
                "label": "ë¹„ë³µê·¼ ê³¼í™œì„±ì´ ê°€ìë¯¸ê·¼ ì–µì œ ìœ ë°œ (ìƒí˜¸ì–µì œ)"
            },
            {
                "id": "edge-29",
                "source": "soleus-inhibition",
                "target": "calf-pain",
                "type": "causes",
                "weight": 0.75,
                "label": "ê°€ìë¯¸ê·¼ ì•½í™”ê°€ ë¹„ë³µê·¼ ê³¼ë¶€í•˜ë¥¼ í†µí•´ í†µì¦ ìœ ë°œ"
            },
            {
                "id": "edge-30",
                "source": "ankle-instability",
                "target": "fibularis-weakness",
                "type": "causes",
                "weight": 0.80,
                "label": "ë°œëª© ë¶ˆì•ˆì •ì´ ë¹„ê³¨ê·¼ ì•½í™” ìœ ë°œ"
            },
            {
                "id": "edge-31",
                "source": "fibularis-weakness",
                "target": "ankle-instability",
                "type": "causes",
                "weight": 0.85,
                "label": "ë¹„ê³¨ê·¼ ì•½í™”ê°€ ë°œëª© ë¶ˆì•ˆì • ì•…í™” (ì•…ìˆœí™˜)"
            },
            {
                "id": "edge-32",
                "source": "tibialis-anterior-dysfunction",
                "target": "gastrocnemius-overactivity",
                "type": "related",
                "weight": 0.70,
                "label": "ì „ê²½ê³¨ê·¼-ë¹„ë³µê·¼ ê¸¸í•­ê·¼ ë¶ˆê· í˜•"
            },
            {
                "id": "edge-33",
                "source": "hip-weakness",
                "target": "gluteus-medius-weakness",
                "type": "includes",
                "weight": 0.90,
                "label": "ê³ ê´€ì ˆ ì•½í™”ëŠ” ì¤‘ë‘”ê·¼ ì•½í™”ë¥¼ í¬í•¨"
            },
            {
                "id": "edge-34",
                "source": "hip-weakness",
                "target": "gluteus-maximus-inhibition",
                "type": "includes",
                "weight": 0.85,
                "label": "ê³ ê´€ì ˆ ì•½í™”ëŠ” ëŒ€ë‘”ê·¼ ì–µì œë¥¼ í¬í•¨"
            },
            {
                "id": "edge-35",
                "source": "gluteus-maximus-inhibition",
                "target": "hamstring-dominance",
                "type": "causes",
                "weight": 0.88,
                "label": "ëŒ€ë‘”ê·¼ ì–µì œê°€ ìŠ¬ê±´ ìš°ì„¸ ë³´ìƒ íŒ¨í„´ ìœ ë°œ"
            },
            {
                "id": "edge-36",
                "source": "prolonged-sitting",
                "target": "gluteus-maximus-inhibition",
                "type": "causes",
                "weight": 0.82,
                "label": "ì¥ì‹œê°„ ì•‰ê¸°ê°€ ëŒ€ë‘”ê·¼ ì–µì œ ìœ ë°œ"
            },
            {
                "id": "edge-37",
                "source": "gluteus-medius-weakness",
                "target": "gait-abnormality",
                "type": "causes",
                "weight": 0.78,
                "label": "ì¤‘ë‘”ê·¼ ì•½í™”ê°€ ë³´í–‰ ì´ìƒ ìœ ë°œ (ê³¨ë°˜ ë‚™í•˜)"
            },
            {
                "id": "edge-38",
                "source": "hamstring-dominance",
                "target": "calf-pain",
                "type": "causes",
                "weight": 0.65,
                "label": "ìŠ¬ê±´ ìš°ì„¸ íŒ¨í„´ì´ í•˜ì§€ ìš´ë™ì‚¬ìŠ¬ ì „ì²´ì— ì˜í–¥"
            }
        ]
    }
    </script>

    <!-- ëª¨ë“  JavaScriptë¥¼ inlineìœ¼ë¡œ í†µí•© -->
    <script>
        console.log('ğŸš€ PT Compensation Wiki initializing...');

        // ì´ë²¤íŠ¸ ë²„ìŠ¤ (ëª¨ë“  ì‹œìŠ¤í…œ ê°„ í†µì‹ )
        class EventBus {
            constructor() {
                this.events = {};
            }

            emit(eventType, data) {
                if (this.events[eventType]) {
                    this.events[eventType].forEach(handler => handler(data));
                }
            }

            on(eventType, handler) {
                if (!this.events[eventType]) {
                    this.events[eventType] = [];
                }
                this.events[eventType].push(handler);
            }

            off(eventType, handler) {
                if (this.events[eventType]) {
                    this.events[eventType] = this.events[eventType].filter(h => h !== handler);
                }
            }
        }

        // ê°„ë‹¨í•œ ê·¸ë˜í”„ ë Œë”ëŸ¬
        class SimpleGraphRenderer {
            constructor(canvas, eventBus) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.eventBus = eventBus;
                this.graph = null;
                this.viewport = { x: 0, y: 0, width: 800, height: 600, zoom: 1.0 };

                // ğŸš€ ì„±ëŠ¥ ìµœì í™”: ë…¸ë“œ ID â†’ ë…¸ë“œ ê°ì²´ ë§µ
                this.nodeMap = new Map();
                // ğŸš€ ì„±ëŠ¥ ìµœì í™”: ë…¸ë“œ ìœ„ì¹˜ ìºì‹œ
                this.nodePositionCache = new Map();
                // ğŸš€ ì„±ëŠ¥ ìµœì í™”: ê°€ì‹œì„± ì´ˆê¸°í™” ì™„ë£Œ í”Œë˜ê·¸
                this.visibilityInitialized = false;

                // ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •
                this.physics = {
                    enabled: true,
                    repulsion: 5000,
                    attraction: 0.01,
                    damping: 0.9,
                    centerPull: 0.002
                };

                this.setupCanvas();
                this.setupEvents();
                this.startPhysicsLoop();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                this.viewport.width = rect.width;
                this.viewport.height = rect.height;
            }

            setupEvents() {
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.viewport.zoom *= zoomFactor;
                    this.render();
                });

                let isDragging = false;
                let lastX, lastY;
                let dragDistance = 0;

                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastX = e.clientX;
                    lastY = e.clientY;
                    dragDistance = 0;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;
                        dragDistance += Math.abs(deltaX) + Math.abs(deltaY);

                        this.viewport.x -= deltaX / this.viewport.zoom;
                        this.viewport.y -= deltaY / this.viewport.zoom;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        this.render();
                    } else {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;

                        // +ë²„íŠ¼ ì˜ì—­ ì²´í¬
                        const isOverButton = this.addButtonArea &&
                            Math.sqrt(
                                Math.pow(mouseX - (this.addButtonArea.x + this.addButtonArea.size/2), 2) +
                                Math.pow(mouseY - (this.addButtonArea.y + this.addButtonArea.size/2), 2)
                            ) <= this.addButtonArea.size / 2;

                        // +ë²„íŠ¼ ìœ„ì— ìˆê±°ë‚˜ ë…¸ë“œ ìœ„ì— ìˆìœ¼ë©´ hoveredNode ìœ ì§€
                        if (!isOverButton) {
                            const newHoveredNode = this.findNodeAtPosition(mouseX, mouseY);
                            if (newHoveredNode || !this.hoveredNode) {
                                this.hoveredNode = newHoveredNode;
                            }
                        }

                        this.mouseX = mouseX;
                        this.mouseY = mouseY;
                        this.render();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (isDragging && dragDistance < 5) {
                        // ë“œë˜ê·¸ê°€ ì•„ë‹Œ í´ë¦­ìœ¼ë¡œ íŒë‹¨
                        this.handleCanvasClick(e);
                    }
                    isDragging = false;
                    dragDistance = 0;
                });

                // ì‚¬ì´ë“œíŒ¨ë„ ë‹«ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸
                document.getElementById('panel-close-btn').addEventListener('click', () => {
                    this.closeNodeInfoPanel();
                });
            }

            handleCanvasClick(e) {
                if (!this.graph) return;

                const rect = this.canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // +ë²„íŠ¼ í´ë¦­ ì²´í¬
                if (this.addButtonArea) {
                    const dist = Math.sqrt(
                        Math.pow(clickX - (this.addButtonArea.x + this.addButtonArea.size/2), 2) +
                        Math.pow(clickY - (this.addButtonArea.y + this.addButtonArea.size/2), 2)
                    );
                    if (dist <= this.addButtonArea.size / 2) {
                        this.addNewNode(this.addButtonArea.node);
                        return;
                    }
                }

                // í´ë¦­í•œ ë…¸ë“œ ì°¾ê¸°
                const clickedNode = this.findNodeAtPosition(clickX, clickY);
                if (clickedNode) {
                    this.openNodeInfoPanel(clickedNode);
                }
            }

            findNodeAtPosition(screenX, screenY) {
                for (const node of this.graph.nodes) {
                    if (node.animationVisible === false) continue;

                    const pos = this.worldToScreen(node.x, node.y);
                    const size = (node.currentSize || node.size || 20) * this.viewport.zoom;

                    const distance = Math.sqrt(
                        Math.pow(screenX - pos.x, 2) + Math.pow(screenY - pos.y, 2)
                    );

                    if (distance <= size) {
                        return node;
                    }
                }
                return null;
            }

            openNodeInfoPanel(node) {
                // ì‚¬ì´ë“œíŒ¨ë„ ì—´ê¸°
                const panel = document.getElementById('node-info-panel');
                panel.classList.add('open');
                document.body.classList.add('panel-open');

                // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                this.setupCanvas();

                // ë…¸ë“œ ì •ë³´ í‘œì‹œ
                this.populateNodeInfo(node);

                // "ì‹œì‘ì ìœ¼ë¡œ ì„¤ì •" ë²„íŠ¼ ì´ë²¤íŠ¸
                const setAsWhy0Btn = document.getElementById('set-as-why0-btn');
                setAsWhy0Btn.onclick = () => {
                    this.setNodeAsWhy0(node);
                };
            }

            closeNodeInfoPanel() {
                const panel = document.getElementById('node-info-panel');
                panel.classList.remove('open');
                document.body.classList.remove('panel-open');

                // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
                setTimeout(() => {
                    this.setupCanvas();
                    this.render();
                }, 300);
            }

            populateNodeInfo(node) {
                // ê¸°ë³¸ ì •ë³´
                document.getElementById('node-label').textContent = node.label;
                document.getElementById('node-type').textContent = this.getNodeTypeDisplay(node.type);

                // ë…¸ë“œ ì•„ì´ì½˜ ì„¤ì •
                const icon = document.querySelector('.node-icon');
                icon.style.backgroundColor = node.color || '#2196f3';
                icon.textContent = this.getNodeIcon(node.type);

                // ì„ìƒ ì •ë³´ê°€ ìˆëŠ” ê²½ìš°
                if (node.clinicalInfo) {
                    const info = node.clinicalInfo;

                    document.getElementById('node-description').textContent = info.description || '-';
                    document.getElementById('node-prevalence').textContent = info.prevalence || '-';
                    document.getElementById('node-evidence').textContent = info.evidence || '-';

                    // ë¦¬ìŠ¤íŠ¸ í˜•íƒœ ì •ë³´ë“¤
                    this.populateList('node-assessment-tools', info.assessmentTools);
                    this.populateList('node-interventions', info.interventions);
                    this.populateList('node-related-conditions', info.relatedConditions);
                    this.populateList('node-references', info.references);
                } else {
                    // clinicalInfoê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ê°’
                    document.getElementById('node-description').textContent = 'ìƒì„¸ ì •ë³´ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤.';
                    document.getElementById('node-prevalence').textContent = '-';
                    document.getElementById('node-evidence').textContent = '-';

                    ['node-assessment-tools', 'node-interventions', 'node-related-conditions', 'node-references'].forEach(id => {
                        document.getElementById(id).innerHTML = '<li>ì •ë³´ ì¤€ë¹„ ì¤‘</li>';
                    });
                }
            }

            populateList(elementId, items) {
                const element = document.getElementById(elementId);
                if (items && items.length > 0) {
                    if (elementId === 'node-references') {
                        element.innerHTML = items.map(item => {
                            if (typeof item === 'object' && item.title) {
                                let fullTextLink = null;
                                let linkLabel = '';

                                if (item.pmc) {
                                    const searchQuery = encodeURIComponent(item.quote || item.section || '');
                                    fullTextLink = `https://www.ncbi.nlm.nih.gov/pmc/articles/${item.pmc}/${searchQuery ? '?term=' + searchQuery : ''}`;
                                    linkLabel = 'ğŸ“„ í’€í…ìŠ¤íŠ¸';
                                } else if (item.doi) {
                                    fullTextLink = `https://doi.org/${item.doi}`;
                                    linkLabel = 'ğŸ“„ DOI';
                                } else if (item.arxiv) {
                                    fullTextLink = `https://arxiv.org/pdf/${item.arxiv}.pdf`;
                                    linkLabel = 'ğŸ“„ PDF';
                                }

                                const citation = `${item.authors ? item.authors + '. ' : ''}${item.title}. ${item.year || ''}.`;
                                const sectionInfo = item.section ? ` <span style="color: #666; font-size: 0.9em;">(${item.section})</span>` : '';
                                const quoteInfo = item.quote ? `<br><span style="color: #888; font-size: 0.85em; font-style: italic;">"${item.quote}"</span>` : '';

                                if (fullTextLink) {
                                    return `<li style="margin-bottom: 12px;">
                                        <div>${citation}${sectionInfo}</div>
                                        ${quoteInfo}
                                        <div style="margin-top: 6px;">
                                            <a href="${fullTextLink}" target="_blank" rel="noopener noreferrer"
                                               style="color: #2196f3; text-decoration: none; font-weight: 500;">
                                                ${linkLabel} â†’
                                            </a>
                                        </div>
                                    </li>`;
                                } else {
                                    return `<li style="margin-bottom: 12px;">${citation}${sectionInfo}${quoteInfo}</li>`;
                                }
                            } else if (typeof item === 'string') {
                                const doiMatch = item.match(/doi:?\s*(10\.\d+\/\S+)/i);
                                const arxivMatch = item.match(/arXiv:\s*(\d+\.\d+)/i);

                                if (doiMatch) {
                                    return `<li><a href="https://doi.org/${doiMatch[1]}" target="_blank" style="color: #2196f3;">${item} ğŸ“„</a></li>`;
                                } else if (arxivMatch) {
                                    return `<li><a href="https://arxiv.org/pdf/${arxivMatch[1]}.pdf" target="_blank" style="color: #2196f3;">${item} ğŸ“„</a></li>`;
                                } else {
                                    const searchQuery = encodeURIComponent(item);
                                    return `<li><a href="https://scholar.google.com/scholar?q=${searchQuery}" target="_blank" style="color: #2196f3;">${item} ğŸ”</a></li>`;
                                }
                            }
                            return `<li>${item}</li>`;
                        }).join('');
                    } else {
                        element.innerHTML = items.map(item => `<li>${item}</li>`).join('');
                    }
                } else {
                    element.innerHTML = '<li>í•´ë‹¹ ì •ë³´ ì—†ìŒ</li>';
                }
            }

            getNodeTypeDisplay(type) {
                const typeMap = {
                    'symptom': 'ì¦ìƒ',
                    'cause': 'ì›ì¸',
                    'lifestyle': 'ìƒí™œìŠµê´€ ìš”ì¸',
                    'muscle-specific': 'ê·¼ìœ¡ íŠ¹ì´ì ',
                    'metabolic': 'ëŒ€ì‚¬ì  ì›ì¸',
                    'training-error': 'í›ˆë ¨ ì˜¤ë¥˜',
                    'biomechanical': 'ìƒì²´ì—­í•™ì '
                };
                return typeMap[type] || type;
            }

            getNodeIcon(type) {
                const iconMap = {
                    'symptom': 'ğŸ©º',
                    'cause': 'ğŸ”',
                    'lifestyle': 'ğŸƒ',
                    'muscle-specific': 'ğŸ’ª',
                    'metabolic': 'âš¡',
                    'training-error': 'âš ï¸',
                    'biomechanical': 'ğŸ¦´'
                };
                return iconMap[type] || 'âšª';
            }

            addNewNode(parentNode) {
                if (!this.graph) return;

                const nodeLabel = prompt('ìƒˆ ë…¸ë“œ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', '');
                if (!nodeLabel || nodeLabel.trim() === '') return;

                const edgeLabel = prompt('í™”ì‚´í‘œì— í‘œì‹œí•  ë‹µì„ ì…ë ¥í•˜ì„¸ìš” (ì˜ˆ: ~ë•Œë¬¸ì—, ~ë¡œ ì¸í•´):', '');

                const logicType = prompt('ë…¼ë¦¬ ê´€ê³„ë¥¼ ì„ íƒí•˜ì„¸ìš”:\n1. í•„ìš”ì¡°ê±´ (í™”ì‚´í‘œ 1ê°œ)\n2. ì¶©ë¶„ì¡°ê±´ (í™”ì‚´í‘œ 2ê°œ)\n\nìˆ«ìë¥¼ ì…ë ¥:', '1');

                // ìƒˆ ë…¸ë“œ ìƒì„±
                const newNodeId = `node-${Date.now()}`;
                const newNode = {
                    id: newNodeId,
                    label: nodeLabel.trim(),
                    type: 'cause',
                    x: parentNode.x + (Math.random() - 0.5) * 200,
                    y: parentNode.y + (Math.random() - 0.5) * 200,
                    size: 25,
                    whyLevel: parentNode.whyLevel + 1,
                    animationVisible: true,
                    alpha: 1,
                    currentSize: 25
                };

                // ìƒˆ ì—£ì§€ ìƒì„±
                const newEdge = {
                    id: `edge-${Date.now()}`,
                    source: parentNode.id,
                    target: newNodeId,
                    type: 'causes',
                    label: edgeLabel && edgeLabel.trim() !== '' ? edgeLabel.trim() : undefined,
                    logicType: logicType === '2' ? 'sufficient' : 'necessary',
                    confidence: 0.8,
                    width: 2,
                    color: '#4A90E2',
                    animationVisible: true,
                    alpha: 1
                };

                // ê·¸ë˜í”„ì— ì¶”ê°€
                this.graph.nodes.push(newNode);
                this.graph.edges.push(newEdge);
                this.nodeMap.set(newNodeId, newNode);

                console.log(`âœ… ìƒˆ ë…¸ë“œ ì¶”ê°€ë¨: ${nodeLabel} (ë¶€ëª¨: ${parentNode.label}, ê´€ê³„: ${newEdge.logicType})`);

                // í™”ë©´ ê°±ì‹ 
                this.hoveredNode = null;
                this.addButtonArea = null;
                this.render();
            }

            setNodeAsWhy0(node) {
                console.log(`ğŸ¯ ìƒˆë¡œìš´ Why0 ì„¤ì •: ${node.label}`);

                // Why ê¹Šì´ ì¬ê³„ì‚°
                this.recalculateWhyDepths(node);

                // ì‚¬ì´ë“œíŒ¨ë„ ë‹«ê¸°
                this.closeNodeInfoPanel();

                console.log('âœ… Why ê¹Šì´ ì¬ê³„ì‚° ì™„ë£Œ - ìƒˆë¡œìš´ ë¶„ì„ ì‹œì‘ì ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }

            async recalculateWhyDepths(rootNode) {
                if (!this.graph) return;

                // ì• ë‹ˆë©”ì´í„°ê°€ ìˆìœ¼ë©´ ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ê¹Šì´ ì¬ê³„ì‚°
                const app = window.ptWiki;
                if (app && app.animator && app.animator.animateDepthRecalculation) {
                    // ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰ (ë‚´ë¶€ì—ì„œ ê¹Šì´ ê³„ì‚° ìˆ˜í–‰)
                    await app.animator.animateDepthRecalculation(rootNode, () => {
                        this.performDepthCalculation(rootNode);
                    });
                } else {
                    // ì• ë‹ˆë©”ì´í„°ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ë°©ì‹
                    this.performDepthCalculation(rootNode);
                    this.render();
                }
            }

            performDepthCalculation(rootNode) {
                console.log('ğŸ”„ ê¹Šì´ ì¬ê³„ì‚° ì‹œì‘:', rootNode.label);

                // 1ë‹¨ê³„: ëª¨ë“  ë…¸ë“œ ì™„ì „ ì´ˆê¸°í™” ë° ê°€ì‹œì„± ê°•ì œ ì„¤ì •
                this.graph.nodes.forEach(node => {
                    node.whyLevel = 0;
                    node.pathHighlight = false;
                    // ê°€ì‹œì„± ê°•ì œ ì„¤ì • (ì ˆëŒ€ falseê°€ ë˜ë©´ ì•ˆ ë¨)
                    node.animationVisible = true;
                    // ì•ŒíŒŒê°’ ê°•ì œ ì„¤ì •
                    node.alpha = 1;
                    // í¬ê¸° ê°•ì œ ì„¤ì •
                    node.currentSize = node.size || 20;
                });

                // 2ë‹¨ê³„: ëª¨ë“  ì—£ì§€ ê°€ì‹œì„± ê°•ì œ ì„¤ì •
                this.graph.edges.forEach(edge => {
                    edge.animationVisible = true;
                    edge.alpha = 1;
                });

                // 3ë‹¨ê³„: ë£¨íŠ¸ ë…¸ë“œë¥¼ Why0ë¡œ ì„¤ì •
                rootNode.whyLevel = 0;

                // 4ë‹¨ê³„: BFSë¥¼ ì‚¬ìš©í•´ì„œ ì—°ê²°ëœ ë…¸ë“œë“¤ì˜ ê¹Šì´ ê³„ì‚°
                const visited = new Set();
                const queue = [{ node: rootNode, depth: 0 }];
                visited.add(rootNode.id);

                while (queue.length > 0) {
                    const { node: currentNode, depth } = queue.shift();

                    // í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ì—£ì§€ë“¤ ì°¾ê¸° (ì–‘ë°©í–¥)
                    const connectedEdges = this.graph.edges.filter(edge =>
                        edge.source === currentNode.id || edge.target === currentNode.id
                    );

                    for (const edge of connectedEdges) {
                        let nextNodeId;

                        if (edge.source === currentNode.id) {
                            nextNodeId = edge.target;
                        } else {
                            nextNodeId = edge.source;
                        }

                        if (!visited.has(nextNodeId)) {
                            const nextNode = this.graph.nodes.find(n => n.id === nextNodeId);
                            if (nextNode) {
                                const newDepth = depth + 1;
                                nextNode.whyLevel = newDepth;
                                nextNode.animationVisible = true; // ëª…ì‹œì  ê°€ì‹œì„±
                                nextNode.alpha = 1;
                                nextNode.currentSize = nextNode.size || 20;

                                queue.push({ node: nextNode, depth: newDepth });
                                visited.add(nextNodeId);
                            }
                        }
                    }
                }

                // 5ë‹¨ê³„: ì—°ê²°ë˜ì§€ ì•Šì€ ë…¸ë“œë“¤ë„ ëª…ì‹œì ìœ¼ë¡œ í‘œì‹œ (ì¤‘ìš”!)
                const unvisitedNodes = this.graph.nodes.filter(n => !visited.has(n.id));
                if (unvisitedNodes.length > 0) {
                    console.log(`âš ï¸ ${unvisitedNodes.length}ê°œì˜ ì—°ê²°ë˜ì§€ ì•Šì€ ë…¸ë“œ ë°œê²¬:`, unvisitedNodes.map(n => n.label));
                    unvisitedNodes.forEach(node => {
                        node.animationVisible = true;
                        node.alpha = 0.5; // ì•½ê°„ íˆ¬ëª…í•˜ê²Œ í‘œì‹œí•˜ì—¬ ì—°ê²° ì•ˆ ë¨ì„ ì‹œê°ì ìœ¼ë¡œ í‘œí˜„
                        node.currentSize = node.size || 20;
                        node.whyLevel = -1; // íŠ¹ìˆ˜ê°’: ì—°ê²° ì•ˆ ëœ ë…¸ë“œ
                    });
                }

                console.log(`âœ… ê¹Šì´ ê³„ì‚° ì™„ë£Œ: ${visited.size}ê°œ ì—°ê²°, ${unvisitedNodes.length}ê°œ ë¯¸ì—°ê²°`);
            }

            updateGraph(graph) {
                this.graph = graph;

                // ğŸš€ ë…¸ë“œ ë§µ êµ¬ì¶• (O(n) â†’ O(1) ê²€ìƒ‰)
                this.nodeMap.clear();
                if (this.graph && this.graph.nodes) {
                    this.graph.nodes.forEach(node => {
                        this.nodeMap.set(node.id, node);
                    });
                }

                // ê°€ì‹œì„± í”Œë˜ê·¸ ë¦¬ì…‹
                this.visibilityInitialized = false;

                this.render();
            }

            startPhysicsLoop() {
                const tick = () => {
                    if (this.physics.enabled && this.graph) {
                        this.applyForces();
                    }
                    requestAnimationFrame(tick);
                };
                requestAnimationFrame(tick);
            }

            applyForces() {
                if (!this.graph || !this.graph.nodes) return;

                const nodes = this.graph.nodes.filter(n => n.animationVisible !== false);

                // ê° ë…¸ë“œì— ì†ë„ ì´ˆê¸°í™”
                nodes.forEach(node => {
                    if (!node.vx) node.vx = 0;
                    if (!node.vy) node.vy = 0;
                });

                // 1. ë°˜ë°œë ¥ (ëª¨ë“  ë…¸ë“œ ìŒ)
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const n1 = nodes[i];
                        const n2 = nodes[j];

                        const dx = n2.x - n1.x;
                        const dy = n2.y - n1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                        const force = this.physics.repulsion / (dist * dist);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;

                        n1.vx -= fx;
                        n1.vy -= fy;
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }

                // 2. ì¸ë ¥ (ì—°ê²°ëœ ë…¸ë“œ)
                if (this.graph.edges) {
                    this.graph.edges.forEach(edge => {
                        const source = this.nodeMap.get(edge.source);
                        const target = this.nodeMap.get(edge.target);

                        if (source && target && source.animationVisible !== false && target.animationVisible !== false) {
                            const dx = target.x - source.x;
                            const dy = target.y - source.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                            const force = dist * this.physics.attraction;
                            const fx = (dx / dist) * force;
                            const fy = (dy / dist) * force;

                            source.vx += fx;
                            source.vy += fy;
                            target.vx -= fx;
                            target.vy -= fy;
                        }
                    });
                }

                // 3. ì¤‘ì‹¬ìœ¼ë¡œ ë‹¹ê¸°ê¸°
                nodes.forEach(node => {
                    node.vx -= node.x * this.physics.centerPull;
                    node.vy -= node.y * this.physics.centerPull;
                });

                // 4. ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë° ê°ì‡ 
                nodes.forEach(node => {
                    node.vx *= this.physics.damping;
                    node.vy *= this.physics.damping;
                    node.x += node.vx;
                    node.y += node.vy;
                });

                this.render();
            }

            worldToScreen(worldX, worldY) {
                return {
                    x: (worldX - this.viewport.x) * this.viewport.zoom + this.viewport.width / 2,
                    y: (worldY - this.viewport.y) * this.viewport.zoom + this.viewport.height / 2
                };
            }

            render() {
                if (!this.graph) return;

                const perfStart = performance.now();

                // ğŸš€ ê°€ì‹œì„± ì´ˆê¸°í™” (ìµœì´ˆ 1íšŒë§Œ ì‹¤í–‰)
                if (!this.visibilityInitialized) {
                    this.graph.nodes.forEach(node => {
                        if (node.animationVisible === undefined) node.animationVisible = true;
                        if (node.alpha === undefined || node.alpha === 0) node.alpha = 1;
                        if (!node.currentSize) node.currentSize = node.size || 20;
                    });

                    this.graph.edges.forEach(edge => {
                        if (edge.animationVisible === undefined) edge.animationVisible = true;
                    });

                    this.visibilityInitialized = true;
                }

                // ë°°ê²½ ì§€ìš°ê¸°
                this.ctx.clearRect(0, 0, this.viewport.width, this.viewport.height);

                // ğŸš€ ë…¸ë“œ ìœ„ì¹˜ ìºì‹œ ê°±ì‹  (ë·°í¬íŠ¸/ì¤Œ ë³€ê²½ ì‹œì—ë§Œ)
                this.nodePositionCache.clear();
                for (const node of this.graph.nodes) {
                    if (node.animationVisible !== false) {
                        this.nodePositionCache.set(node.id, this.worldToScreen(node.x, node.y));
                    }
                }

                // ì—£ì§€ ê·¸ë¦¬ê¸° (ìµœì í™”: Map ê²€ìƒ‰ O(1))
                for (const edge of this.graph.edges) {
                    const sourceNode = this.nodeMap.get(edge.source);
                    const targetNode = this.nodeMap.get(edge.target);

                    // ê°€ì‹œì„± ì²´í¬: falseê°€ ì•„ë‹ˆë©´ ëª¨ë‘ í‘œì‹œ (undefined, true ëª¨ë‘ í‘œì‹œ)
                    const sourceVisible = sourceNode && sourceNode.animationVisible !== false;
                    const targetVisible = targetNode && targetNode.animationVisible !== false;
                    const edgeVisible = edge.animationVisible !== false;

                    if (sourceVisible && targetVisible && edgeVisible) {

                        // ğŸš€ ìºì‹œëœ ìœ„ì¹˜ ì‚¬ìš©
                        const sourcePos = this.nodePositionCache.get(edge.source);
                        const targetPos = this.nodePositionCache.get(edge.target);

                        // ì ì§„ì  ê·¸ë¦¬ê¸° ì§€ì›
                        const drawProgress = edge.drawProgress !== undefined ? edge.drawProgress : 1;
                        const currentTargetX = sourcePos.x + (targetPos.x - sourcePos.x) * drawProgress;
                        const currentTargetY = sourcePos.y + (targetPos.y - sourcePos.y) * drawProgress;

                        // ì•ŒíŒŒ ì§€ì›
                        this.ctx.globalAlpha = edge.alpha !== undefined ? edge.alpha : 1;

                        // ì„  ê·¸ë¦¬ê¸°
                        this.ctx.beginPath();
                        this.ctx.moveTo(sourcePos.x, sourcePos.y);
                        this.ctx.lineTo(currentTargetX, currentTargetY);
                        this.ctx.strokeStyle = edge.color || '#666';

                        // ì• ë‹ˆë©”ì´ì…˜ ë„ˆë¹„ ë˜ëŠ” ê¸°ë³¸ ë„ˆë¹„
                        let lineWidth = edge.animatedWidth || edge.width || 2;
                        if (edge.pathHighlight) lineWidth *= 1.5;
                        this.ctx.lineWidth = lineWidth;

                        this.ctx.stroke();

                        // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° (ë…¸ë“œì™€ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ë…¸ë“œ ê²½ê³„ì—ì„œ ì‹œì‘)
                        const targetNodeSize = (targetNode.currentSize || targetNode.size || 20) * this.viewport.zoom;
                        const angle = Math.atan2(currentTargetY - sourcePos.y, currentTargetX - sourcePos.x);

                        // íƒ€ê²Ÿ ë…¸ë“œ ê²½ê³„ê¹Œì§€ë§Œ ì„  ê·¸ë¦¬ê¸°
                        const arrowTipX = currentTargetX - targetNodeSize * Math.cos(angle);
                        const arrowTipY = currentTargetY - targetNodeSize * Math.sin(angle);

                        if (drawProgress > 0.1) {
                            // í™”ì‚´í‘œ í¬ê¸° (í•„ìš”ì¡°ê±´/ì¶©ë¶„ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥´ê²Œ)
                            const arrowType = edge.logicType || 'necessary'; // 'necessary', 'sufficient', 'both'
                            let arrowLength = 15;
                            let arrowWidth = Math.PI / 6;

                            // í™”ì‚´í‘œ ê°•ì¡° íš¨ê³¼
                            if (edge.arrowEmphasis && edge.arrowEmphasis.active) {
                                const elapsed = Date.now() - edge.arrowEmphasis.startTime;
                                const progress = Math.min(elapsed / edge.arrowEmphasis.duration, 1);
                                arrowLength = 15 + 8 * Math.sin(progress * Math.PI * 2);
                                this.ctx.lineWidth = lineWidth * (1 + 0.5 * Math.sin(progress * Math.PI * 4));

                                if (progress >= 1) {
                                    edge.arrowEmphasis.active = false;
                                }
                            }

                            this.ctx.strokeStyle = edge.color || '#666';
                            this.ctx.fillStyle = edge.color || '#666';

                            // í™”ì‚´í‘œ ê·¸ë¦¬ê¸° (ì±„ì›Œì§„ ì‚¼ê°í˜•)
                            this.ctx.beginPath();
                            this.ctx.moveTo(arrowTipX, arrowTipY);
                            this.ctx.lineTo(
                                arrowTipX - arrowLength * Math.cos(angle - arrowWidth),
                                arrowTipY - arrowLength * Math.sin(angle - arrowWidth)
                            );
                            this.ctx.lineTo(
                                arrowTipX - arrowLength * Math.cos(angle + arrowWidth),
                                arrowTipY - arrowLength * Math.sin(angle + arrowWidth)
                            );
                            this.ctx.closePath();
                            this.ctx.fill();

                            // í•„ìš”ì¡°ê±´/ì¶©ë¶„ì¡°ê±´ í‘œì‹œ
                            if (arrowType === 'sufficient') {
                                // ì¶©ë¶„ì¡°ê±´: ì´ì¤‘ í™”ì‚´í‘œ
                                this.ctx.beginPath();
                                this.ctx.moveTo(arrowTipX - arrowLength, arrowTipY);
                                this.ctx.lineTo(
                                    arrowTipX - arrowLength * 1.5 * Math.cos(angle - arrowWidth),
                                    arrowTipY - arrowLength * 1.5 * Math.sin(angle - arrowWidth)
                                );
                                this.ctx.lineTo(
                                    arrowTipX - arrowLength * 1.5 * Math.cos(angle + arrowWidth),
                                    arrowTipY - arrowLength * 1.5 * Math.sin(angle + arrowWidth)
                                );
                                this.ctx.closePath();
                                this.ctx.fill();
                            }
                        }

                        // ì—£ì§€ ë¼ë²¨ ê·¸ë¦¬ê¸° (ì„ ì„ ë”°ë¼ íšŒì „)
                        if (edge.label && this.viewport.zoom > 0.3) {
                            const midX = (sourcePos.x + currentTargetX) / 2;
                            const midY = (sourcePos.y + currentTargetY) / 2;

                            // ì„ ì˜ ê°ë„ ê³„ì‚°
                            const textAngle = Math.atan2(currentTargetY - sourcePos.y, currentTargetX - sourcePos.x);

                            // í…ìŠ¤íŠ¸ê°€ ê±°ê¾¸ë¡œ ë˜ì§€ ì•Šë„ë¡ ì¡°ì •
                            let displayAngle = textAngle;
                            if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) {
                                displayAngle = textAngle + Math.PI;
                            }

                            this.ctx.save();
                            this.ctx.translate(midX, midY);
                            this.ctx.rotate(displayAngle);

                            const edgeFontSize = (this.textScale || 1) * Math.max(10, 11 * this.viewport.zoom);
                            this.ctx.font = `${edgeFontSize}px Arial`;
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'bottom';

                            // ë°°ê²½ ë°•ìŠ¤
                            const textWidth = this.ctx.measureText(edge.label).width;
                            const padding = 4;
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                            this.ctx.fillRect(-textWidth/2 - padding, -edgeFontSize - 2, textWidth + padding * 2, edgeFontSize + 4);

                            // ë¼ë²¨ í…ìŠ¤íŠ¸
                            this.ctx.fillStyle = '#2C3E50';
                            this.ctx.fillText(edge.label, 0, -2);

                            this.ctx.restore();
                        }

                        this.ctx.globalAlpha = 1; // ì•ŒíŒŒ ë¦¬ì…‹
                    }
                }

                // ë…¸ë“œ ê·¸ë¦¬ê¸° (ê°œì„ ëœ ì• ë‹ˆë©”ì´ì…˜ ì§€ì›)
                for (const node of this.graph.nodes) {
                    // ê°€ì‹œì„± ì²´í¬: falseì¸ ê²½ìš°ë§Œ ê±´ë„ˆë›°ê¸° (undefined, trueëŠ” ëª¨ë‘ í‘œì‹œ)
                    if (node.animationVisible === false) continue;

                    const pos = this.worldToScreen(node.x, node.y);
                    let size = (node.currentSize || node.size || 20) * this.viewport.zoom;

                    // ì•ŒíŒŒ ì§€ì›
                    this.ctx.globalAlpha = node.alpha !== undefined ? node.alpha : 1;

                    // í„ìŠ¤ íš¨ê³¼ (ë³‘í–‰ ì›ì¸)
                    if (node.isParallelCause && node.pulsePhase !== undefined) {
                        const pulseScale = 1 + 0.2 * Math.sin(node.pulsePhase);
                        size *= pulseScale;
                    }

                    // ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸ í„ìŠ¤
                    if (node.pathHighlight && node.highlightPulse) {
                        const elapsed = Date.now() - node.highlightPulse;
                        const pulseScale = 1 + 0.3 * Math.sin((elapsed / 200) % (Math.PI * 2));
                        size *= pulseScale;
                    }

                    // ë…¸ë“œ ì›
                    this.ctx.beginPath();
                    this.ctx.arc(pos.x, pos.y, size, 0, 2 * Math.PI);

                    // ìµœì‹  ë…¸ë“œëŠ” ì§„í•œ íŒŒë‘, ì•„ë‹ˆë©´ í•˜ëŠ˜ìƒ‰
                    let fillColor = node.highlightColor || node.color || '#87CEEB';

                    // Why ë ˆë²¨ í‘œì‹œë¥¼ ìœ„í•œ í…Œë‘ë¦¬
                    if (node.whyLevel > 0) {
                        this.ctx.lineWidth = 3;
                        this.ctx.strokeStyle = '#4A90E2';
                    } else {
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeStyle = '#5BA3E8';
                    }

                    this.ctx.fillStyle = fillColor;
                    this.ctx.fill();
                    this.ctx.stroke();

                    // ë…¸ë“œ ì•ˆì— ë¼ë²¨ í‘œì‹œ
                    const fontSize = (this.textScale || 1) * Math.max(10, 12 * this.viewport.zoom);
                    this.ctx.font = `${fontSize}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';

                    // í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ì²˜ë¦¬
                    const maxWidth = size * 1.8;
                    const words = node.label.split(' ');
                    let lines = [];
                    let currentLine = '';

                    for (const word of words) {
                        const testLine = currentLine + (currentLine ? ' ' : '') + word;
                        const metrics = this.ctx.measureText(testLine);
                        if (metrics.width > maxWidth && currentLine !== '') {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    }
                    if (currentLine) lines.push(currentLine);

                    // ì¤„ ìˆ˜ì— ë”°ë¼ ìœ„ì¹˜ ì¡°ì •
                    const lineHeight = fontSize * 1.2;
                    const totalHeight = lines.length * lineHeight;
                    const startY = pos.y - totalHeight / 2 + lineHeight / 2;

                    this.ctx.fillStyle = '#FFFFFF';
                    lines.forEach((line, i) => {
                        this.ctx.fillText(line, pos.x, startY + i * lineHeight);
                    });

                    // Why ë ˆë²¨ í‘œì‹œ (ì™œ? ë°°ì§€)
                    if (node.whyLevel > 0) {
                        const badgeSize = fontSize * 0.8;
                        const badgeX = pos.x - size * 0.7;
                        const badgeY = pos.y - size * 0.7;

                        // ë°°ì§€ ë°°ê²½
                        this.ctx.fillStyle = '#FF6B6B';
                        this.ctx.beginPath();
                        this.ctx.arc(badgeX, badgeY, badgeSize, 0, 2 * Math.PI);
                        this.ctx.fill();

                        // "ì™œ?" í…ìŠ¤íŠ¸
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = `bold ${badgeSize * 1.2}px Arial`;
                        this.ctx.fillText('ì™œ?', badgeX, badgeY);
                    }

                    // ìµœì‹  ë…¸ë“œ í‘œì‹œ (NEW ë°°ì§€)
                    if (node.isRecent) {
                        const badgeSize = fontSize * 0.6;
                        const badgeX = pos.x + size * 0.7;
                        const badgeY = pos.y - size * 0.7;

                        // ë°°ì§€ ë°°ê²½
                        this.ctx.fillStyle = '#10B981';
                        this.ctx.beginPath();
                        this.ctx.arc(badgeX, badgeY, badgeSize, 0, 2 * Math.PI);
                        this.ctx.fill();

                        // "NEW" í…ìŠ¤íŠ¸
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = `bold ${badgeSize * 0.9}px Arial`;
                        this.ctx.fillText('N', badgeX, badgeY);
                    }

                    // ìˆœì„œë„ ë ˆì´ë¸” (ë¸”ë£¨ ë°•ìŠ¤ ëŒ€ì‹  ìº”ë²„ìŠ¤ì— ì§ì ‘)
                    if (node.flowchartLabel && Date.now() < node.flowchartLabel.showUntil) {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        this.ctx.font = `bold ${Math.max(12, 14 * this.viewport.zoom)}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'bottom';

                        // ë°°ê²½ ë°•ìŠ¤
                        const textWidth = this.ctx.measureText(node.flowchartLabel.text).width;
                        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        this.ctx.fillRect(pos.x - textWidth/2 - 5, pos.y - size - 35, textWidth + 10, 25);

                        // í…ìŠ¤íŠ¸
                        this.ctx.fillStyle = '#333';
                        this.ctx.fillText(node.flowchartLabel.text, pos.x, pos.y - size - 15);
                    }

                    this.ctx.globalAlpha = 1; // ì•ŒíŒŒ ë¦¬ì…‹
                }

                // í˜¸ë²„ëœ ë…¸ë“œì— +ë²„íŠ¼ í‘œì‹œ
                if (this.hoveredNode && this.mouseX && this.mouseY) {
                    const pos = this.worldToScreen(this.hoveredNode.x, this.hoveredNode.y);
                    const nodeSize = (this.hoveredNode.currentSize || this.hoveredNode.size || 20) * this.viewport.zoom;
                    const buttonSize = 24;
                    const buttonX = pos.x + nodeSize + 10;
                    const buttonY = pos.y - buttonSize / 2;

                    // +ë²„íŠ¼ ë°°ê²½
                    this.ctx.fillStyle = '#2196f3';
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();

                    // + ê¸°í˜¸
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(buttonX + buttonSize/2 - 6, buttonY + buttonSize/2);
                    this.ctx.lineTo(buttonX + buttonSize/2 + 6, buttonY + buttonSize/2);
                    this.ctx.moveTo(buttonX + buttonSize/2, buttonY + buttonSize/2 - 6);
                    this.ctx.lineTo(buttonX + buttonSize/2, buttonY + buttonSize/2 + 6);
                    this.ctx.stroke();

                    // +ë²„íŠ¼ í´ë¦­ ì˜ì—­ ì €ì¥
                    this.addButtonArea = {
                        x: buttonX,
                        y: buttonY,
                        size: buttonSize,
                        node: this.hoveredNode
                    };
                } else {
                    this.addButtonArea = null;
                }

                const perfEnd = performance.now();
                const renderTime = perfEnd - perfStart;

                if (window.perfStats === undefined) {
                    window.perfStats = { total: 0, count: 0, max: 0, min: Infinity };
                }
                window.perfStats.total += renderTime;
                window.perfStats.count++;
                window.perfStats.max = Math.max(window.perfStats.max, renderTime);
                window.perfStats.min = Math.min(window.perfStats.min, renderTime);

                if (window.perfStats.count % 60 === 0) {
                    const avg = window.perfStats.total / window.perfStats.count;
                    console.log(`ğŸ“Š ë Œë”ë§ ì„±ëŠ¥ (60í”„ë ˆì„ í‰ê· ): ${avg.toFixed(2)}ms | ìµœëŒ€: ${window.perfStats.max.toFixed(2)}ms | ìµœì†Œ: ${window.perfStats.min.toFixed(2)}ms | FPS: ${(1000/avg).toFixed(1)}`);
                }
            }
        }

        // ê°œì„ ëœ 5Why ìˆœì„œë„ ì• ë‹ˆë©”ì´í„°
        class Enhanced5WhyAnimator {
            constructor(renderer, eventBus) {
                this.renderer = renderer;
                this.eventBus = eventBus;
                this.animationDuration = 800;
                this.isAnimating = false;
                this.currentPath = [];
                this.whyLevel = 0;
            }

            async startDemo() {
                if (this.isAnimating || !this.renderer.graph) return;

                this.isAnimating = true;
                this.whyLevel = 0;
                this.currentPath = [];
                console.log('ğŸ¬ 5Why ìˆœì„œë„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘...');

                const graph = this.renderer.graph;

                // ëª¨ë“  ìš”ì†Œ ì´ˆê¸°í™”
                this.resetGraphForAnimation(graph);

                // 5Why íƒìƒ‰ ê²½ë¡œ (ìˆœì„œë„ ìŠ¤íƒ€ì¼)
                const explorationPath = [
                    {
                        type: 'node',
                        id: 'calf-pain',
                        whyLevel: 1,
                        label: 'Why1: ì¢…ì•„ë¦¬ í†µì¦?',
                        description: 'ë¬¸ì œ ì‹ë³„'
                    },
                    {
                        type: 'edge',
                        id: 'edge-1',
                        description: 'ê°€ì¥ ì§ì ‘ì  ì›ì¸ íƒìƒ‰',
                        confidence: 0.85
                    },
                    {
                        type: 'node',
                        id: 'muscle-fatigue',
                        whyLevel: 2,
                        label: 'Why2: ê·¼ìœ¡ í”¼ë¡œ?',
                        description: 'ì£¼ìš” ì›ì¸ ì‹ë³„'
                    },
                    {
                        type: 'edge',
                        id: 'edge-4',
                        description: 'ê·¼ë³¸ ì›ì¸ìœ¼ë¡œ ì¶”ì ',
                        confidence: 0.80
                    },
                    {
                        type: 'node',
                        id: 'biomechanical-dysfunction',
                        whyLevel: 3,
                        label: 'Why3: ìƒì²´ì—­í•™ì  ì´ìƒ?',
                        description: 'ì‹œìŠ¤í…œ ë¶„ì„'
                    },
                    {
                        type: 'edge',
                        id: 'edge-8',
                        description: 'ë¼ì´í”„ìŠ¤íƒ€ì¼ ìš”ì¸ ì—°ê²°',
                        confidence: 0.60
                    },
                    {
                        type: 'node',
                        id: 'poor-footwear',
                        whyLevel: 4,
                        label: 'Why4: ë¶€ì ì ˆí•œ ì‹ ë°œ?',
                        description: 'êµ¬ì²´ì  ì›ì¸'
                    },
                    {
                        type: 'parallel_cause',
                        id: 'prolonged-sitting',
                        whyLevel: 4,
                        label: 'Why4: ì¥ì‹œê°„ ì•‰ê¸°?',
                        description: 'ë³‘í–‰ ì›ì¸ ë°œê²¬'
                    }
                ];

                for (const step of explorationPath) {
                    await this.animateExplorationStep(step, graph);
                    this.currentPath.push(step);
                }

                // ìµœì¢… ê²½ë¡œ í•˜ì´ë¼ì´íŠ¸
                await this.highlightCompletePath(graph);

                this.isAnimating = false;
                console.log('âœ… 5Why ìˆœì„œë„ ì™„ì„±!');
            }

            resetGraphForAnimation(graph) {
                graph.nodes.forEach(node => {
                    node.animationVisible = false;
                    node.whyLevel = 0;
                    node.pathHighlight = false;
                    node.currentSize = 5;
                    node.targetSize = node.size;
                });
                graph.edges.forEach(edge => {
                    edge.animationVisible = false;
                    edge.drawProgress = 0;
                    edge.pathHighlight = false;
                });
            }

            async animateExplorationStep(step, graph) {
                return new Promise(resolve => {
                    if (step.type === 'node') {
                        const node = graph.nodes.find(n => n.id === step.id);
                        if (node) {
                            node.animationVisible = true;
                            node.whyLevel = step.whyLevel;
                            node.currentSize = 8;

                            // ë…¸ë“œ í˜ì´ë“œì¸ ë° í¬ê¸° ì¦ê°€
                            const startTime = performance.now();
                            const animate = (currentTime) => {
                                const elapsed = currentTime - startTime;
                                const progress = Math.min(elapsed / this.animationDuration, 1);
                                const easeProgress = 1 - Math.pow(1 - progress, 3);

                                node.currentSize = 8 + (node.size - 8) * easeProgress;
                                node.alpha = progress;

                                // Why ë ˆë²¨ì— ë”°ë¥¸ ìƒ‰ìƒ ê°•ì¡°
                                const baseColor = node.color || '#2196f3';
                                const whyIntensity = Math.min(step.whyLevel * 0.2, 0.8);
                                node.highlightColor = this.interpolateColor(baseColor, '#ff4444', whyIntensity);

                                this.renderer.render();

                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    // ìˆœì„œë„ ë ˆì´ë¸” í‘œì‹œ (ë¸”ë£¨ ë°•ìŠ¤ ëŒ€ì‹  ì§ì ‘ ìº”ë²„ìŠ¤ì—)
                                    this.showFlowchartLabel(node, step.label, step.description);
                                    setTimeout(resolve, 800);
                                }
                            };
                            requestAnimationFrame(animate);
                        }
                    } else if (step.type === 'edge') {
                        const edge = graph.edges.find(e => e.id === step.id);
                        if (edge) {
                            edge.animationVisible = true;
                            edge.drawProgress = 0;

                            // í™”ì‚´í‘œ ë°©í–¥ì„± ê°•ì¡°ë¥¼ ìœ„í•œ ì ì§„ì  ê·¸ë¦¬ê¸°
                            const startTime = performance.now();
                            const animate = (currentTime) => {
                                const elapsed = currentTime - startTime;
                                const progress = Math.min(elapsed / (this.animationDuration * 1.5), 1);

                                edge.drawProgress = progress;
                                edge.alpha = progress;

                                // ì‹ ë¢°ë„ì— ë”°ë¥¸ ì„  ë‘ê»˜
                                edge.animatedWidth = (step.confidence || 0.5) * 4 * progress;

                                this.renderer.render();

                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    // í™”ì‚´í‘œ ë°©í–¥ ê°•ì¡°
                                    this.emphasizeArrowDirection(edge);
                                    setTimeout(resolve, 400);
                                }
                            };
                            requestAnimationFrame(animate);
                        }
                    } else if (step.type === 'parallel_cause') {
                        // ë³‘í–‰ ì›ì¸ ê°•ì¡°
                        const node = graph.nodes.find(n => n.id === step.id);
                        if (node) {
                            node.animationVisible = true;
                            node.whyLevel = step.whyLevel;
                            node.isParallelCause = true;

                            const startTime = performance.now();
                            const animate = (currentTime) => {
                                const elapsed = currentTime - startTime;
                                const progress = Math.min(elapsed / this.animationDuration, 1);

                                node.currentSize = node.size * (0.5 + 0.5 * progress);
                                node.alpha = progress;
                                node.pulsePhase = (elapsed / 200) % (Math.PI * 2); // í„ìŠ¤ íš¨ê³¼

                                this.renderer.render();

                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    this.showFlowchartLabel(node, step.label, step.description);
                                    setTimeout(resolve, 600);
                                }
                            };
                            requestAnimationFrame(animate);
                        }
                    }
                });
            }

            showFlowchartLabel(node, label, description) {
                // ìº”ë²„ìŠ¤ì— ì§ì ‘ ë ˆì´ë¸” í‘œì‹œ (ë¸”ë£¨ ë°•ìŠ¤ ì œê±°)
                const canvas = this.renderer.canvas;
                const ctx = canvas.getContext('2d');

                // ì„ì‹œë¡œ ë ˆì´ë¸” ì •ë³´ë¥¼ ë…¸ë“œì— ì €ì¥ (ë Œë”ëŸ¬ì—ì„œ ê·¸ë¦¬ë„ë¡)
                node.flowchartLabel = {
                    text: label,
                    description: description,
                    showUntil: Date.now() + 2000
                };

                console.log(`ğŸ” ${label}: ${description}`);
            }

            emphasizeArrowDirection(edge) {
                // í™”ì‚´í‘œ ë°©í–¥ ê°•ì¡°ë¥¼ ìœ„í•œ ì†ì„± ì„¤ì •
                edge.arrowEmphasis = {
                    active: true,
                    startTime: Date.now(),
                    duration: 1000
                };
            }

            interpolateColor(color1, color2, factor) {
                // ê°„ë‹¨í•œ ìƒ‰ìƒ ë³´ê°„
                if (factor <= 0) return color1;
                if (factor >= 1) return color2;

                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);

                if (!c1 || !c2) return color1;

                const r = Math.round(c1.r + (c2.r - c1.r) * factor);
                const g = Math.round(c1.g + (c2.g - c1.g) * factor);
                const b = Math.round(c1.b + (c2.b - c1.b) * factor);

                return `rgb(${r}, ${g}, ${b})`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            async highlightCompletePath(graph) {
                // ì „ì²´ íƒìƒ‰ ê²½ë¡œë¥¼ ìˆœì„œë„ ìŠ¤íƒ€ì¼ë¡œ í•˜ì´ë¼ì´íŠ¸
                const pathNodes = graph.nodes.filter(n => n.whyLevel > 0);
                const pathEdges = graph.edges.filter(e => e.drawProgress > 0);

                // ìˆœì°¨ì ìœ¼ë¡œ ê²½ë¡œ ê°•ì¡°
                for (let level = 1; level <= Math.max(...pathNodes.map(n => n.whyLevel)); level++) {
                    const levelNodes = pathNodes.filter(n => n.whyLevel === level);
                    levelNodes.forEach(node => {
                        node.pathHighlight = true;
                        node.highlightPulse = Date.now();
                    });

                    this.renderer.render();
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                console.log('ğŸ¯ 5Why ë¶„ì„ ì™„ë£Œ - ì²´ê³„ì ì¸ ì›ì¸ íƒìƒ‰ ê²°ê³¼ë¥¼ í™•ì¸í•˜ì„¸ìš”!');
            }

            async animateDepthRecalculation(newRootNode, recalculateCallback) {
                if (this.isAnimating) return;

                this.isAnimating = true;
                console.log(`ğŸ”„ ìƒˆë¡œìš´ Why0 ì„¤ì • ì• ë‹ˆë©”ì´ì…˜: ${newRootNode.label}`);

                const graph = this.renderer.graph;
                if (!graph) {
                    this.isAnimating = false;
                    return;
                }

                // 1ë‹¨ê³„: ê¸°ì¡´ Why ë ˆë²¨ í˜ì´ë“œì•„ì›ƒ
                await this.fadeOutOldWhyLevels(graph);

                // 2ë‹¨ê³„: ìƒˆë¡œìš´ ë£¨íŠ¸ ë…¸ë“œ ê°•ì¡°
                await this.highlightNewRoot(newRootNode);

                // 2.5ë‹¨ê³„: ê¹Šì´ ì¬ê³„ì‚° ì‹¤í–‰ (ì• ë‹ˆë©”ì´ì…˜ ì¤‘ê°„ì—!)
                if (recalculateCallback) {
                    recalculateCallback();
                }

                // 3ë‹¨ê³„: ìƒˆë¡œìš´ ê¹Šì´ ìˆœì°¨ì  í‘œì‹œ
                await this.revealNewDepthStructure(graph, newRootNode);

                this.isAnimating = false;
                console.log('âœ… Why ê¹Šì´ ì¬ì„¤ì • ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ!');
            }

            async fadeOutOldWhyLevels(graph) {
                return new Promise(resolve => {
                    const duration = 500;
                    const startTime = performance.now();

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const fadeProgress = 1 - progress;

                        // ê¸°ì¡´ Why ë ˆë²¨ í‘œì‹œ í˜ì´ë“œì•„ì›ƒ (ë…¸ë“œ ìì²´ëŠ” ìœ ì§€)
                        graph.nodes.forEach(node => {
                            if (node.whyLevel > 0) {
                                node.whyLevelAlpha = fadeProgress;
                            }
                            // ë…¸ë“œ ê°€ì‹œì„±ì€ í•­ìƒ ìœ ì§€
                            node.animationVisible = true;
                        });

                        this.renderer.render();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // í˜ì´ë“œì•„ì›ƒ ì™„ë£Œ í›„ ì •ë¦¬ (ê°€ì‹œì„± ìœ ì§€)
                            graph.nodes.forEach(node => {
                                node.whyLevelAlpha = 1;
                                node.whyLevel = 0;
                                node.animationVisible = true; // ëª…ì‹œì  ê°€ì‹œì„± ìœ ì§€
                            });
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            async highlightNewRoot(rootNode) {
                return new Promise(resolve => {
                    const duration = 800;
                    const startTime = performance.now();

                    const originalSize = rootNode.size;
                    rootNode.newRootHighlight = true;

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // í„ìŠ¤ íš¨ê³¼
                        const pulseScale = 1 + 0.5 * Math.sin(progress * Math.PI * 4);
                        rootNode.currentSize = originalSize * pulseScale;

                        // ìƒ‰ìƒ ë³€í™”
                        const intensity = Math.sin(progress * Math.PI * 2);
                        rootNode.newRootPulse = intensity;

                        this.renderer.render();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            rootNode.currentSize = originalSize;
                            rootNode.newRootHighlight = false;
                            rootNode.newRootPulse = 0;
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            async revealNewDepthStructure(graph, rootNode) {
                // ë£¨íŠ¸ ë…¸ë“œ(Why0) ë¨¼ì € ì™„ì „íˆ í‘œì‹œ
                rootNode.alpha = 1;
                rootNode.currentSize = rootNode.size || 20;
                rootNode.animationVisible = true;
                this.renderer.render();

                // ìƒˆë¡œìš´ ê¹Šì´ êµ¬ì¡°ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ í‘œì‹œ
                const maxDepth = Math.max(...graph.nodes.map(n => n.whyLevel));

                for (let depth = 1; depth <= maxDepth; depth++) {
                    const nodesAtDepth = graph.nodes.filter(n => n.whyLevel === depth);

                    if (nodesAtDepth.length === 0) continue;

                    await this.animateDepthLevel(nodesAtDepth, depth);
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                // ì—°ê²° ì•ˆ ëœ ë…¸ë“œë“¤ë„ í‘œì‹œ í™•ì¸
                const unconnectedNodes = graph.nodes.filter(n => n.whyLevel === -1);
                unconnectedNodes.forEach(node => {
                    node.alpha = 0.5;
                    node.currentSize = node.size || 20;
                    node.animationVisible = true;
                });
            }

            async animateDepthLevel(nodes, depth) {
                return new Promise(resolve => {
                    const duration = 600;
                    const startTime = performance.now();

                    // ê° ë…¸ë“œì˜ ì´ˆê¸° ìƒíƒœ ì„¤ì • (ê°€ì‹œì„± í™•ë³´)
                    nodes.forEach(node => {
                        node.depthRevealProgress = 0;
                        node.depthRevealActive = true;
                        node.animationVisible = true; // ëª…ì‹œì  ê°€ì‹œì„± ì„¤ì •
                    });

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easeProgress = 1 - Math.pow(1 - progress, 3);

                        nodes.forEach((node, index) => {
                            // ìˆœì°¨ì  ë“±ì¥ (ìŠ¤íƒœê±°ë§)
                            const staggerDelay = index * 0.1;
                            const nodeProgress = Math.max(0, Math.min(1, (progress - staggerDelay) / (1 - staggerDelay)));

                            node.depthRevealProgress = nodeProgress;

                            // í¬ê¸° ì• ë‹ˆë©”ì´ì…˜ (ìµœì†Œ í¬ê¸° ë³´ì¥)
                            const targetSize = node.size;
                            node.currentSize = Math.max(5, targetSize * nodeProgress);

                            // ì•ŒíŒŒ ì• ë‹ˆë©”ì´ì…˜ (ìµœì†Œ ì•ŒíŒŒê°’ ë³´ì¥)
                            node.alpha = Math.max(0.3, nodeProgress);

                            // ê°€ì‹œì„± í•­ìƒ ìœ ì§€
                            node.animationVisible = true;
                        });

                        this.renderer.render();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì •ë¦¬ (ê°€ì‹œì„± ì™„ì „ ë³µêµ¬)
                            nodes.forEach(node => {
                                node.depthRevealActive = false;
                                node.depthRevealProgress = 1;
                                node.alpha = 1;
                                node.currentSize = node.size;
                                node.animationVisible = true; // ëª…ì‹œì  ê°€ì‹œì„± ë³´ì¥
                            });
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            // ê¸°ì¡´ startDemoì™€ í˜¸í™˜ì„±ì„ ìœ„í•œ ë˜í¼
            async triggerDepthRecalculationAnimation(newRootNode) {
                await this.animateDepthRecalculation(newRootNode);
            }
        }

        // ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜
        class PTCompensationWiki {
            constructor(canvas) {
                this.canvas = canvas;
                this.eventBus = new EventBus();
                this.renderer = new SimpleGraphRenderer(canvas, this.eventBus);
                this.animator = new Enhanced5WhyAnimator(this.renderer, this.eventBus);

                this.createUI();
                this.loadDummyData();
            }

            createUI() {
                // ë©”ì¸ ì»¨íŠ¸ë¡¤ íŒ¨ë„
                const controlPanel = document.createElement('div');
                controlPanel.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    background: white;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    padding: 15px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                    z-index: 1000;
                `;

                controlPanel.innerHTML = `
                    <h3 style="margin: 0 0 15px 0;">ğŸ¥ PT ë³´ìƒì‘ìš© ìœ„í‚¤</h3>

                    <div class="control-section">
                        <button id="start-demo-btn" class="main-button primary">
                            ğŸ¬ 5Why ì• ë‹ˆë©”ì´ì…˜
                        </button>
                        <button id="toggle-physics-btn" class="main-button primary">
                            âš¡ ë¬¼ë¦¬ì—”ì§„: ON
                        </button>
                    </div>

                    <div class="control-section">
                        <button id="toggle-physics-panel" class="main-button" style="width: 100%; text-align: left;">
                            âš™ï¸ ë¬¼ë¦¬ ì—”ì§„ ì„¤ì • â–¼
                        </button>
                        <div id="physics-controls" style="display: none; margin-top: 10px;">
                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #666;">
                                ğŸ¯ ì¤‘ì‹¬ í˜ (Center Force)
                            </label>
                            <input type="range" id="center-force-slider" min="0" max="0.01" step="0.0005" value="0.002"
                                   style="width: 100%; margin-bottom: 3px;">
                            <div style="text-align: center; font-size: 10px; color: #999; margin-bottom: 8px;" id="center-force-value">0.002</div>

                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #666;">
                                ğŸ’¥ ë°˜ë°œë ¥ (Repulsion)
                            </label>
                            <input type="range" id="repulsion-slider" min="1000" max="20000" step="500" value="5000"
                                   style="width: 100%; margin-bottom: 3px;">
                            <div style="text-align: center; font-size: 10px; color: #999; margin-bottom: 8px;" id="repulsion-value">5000</div>

                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #666;">
                                ğŸ”— ë§í¬ ì¸ë ¥ (Link Force)
                            </label>
                            <input type="range" id="attraction-slider" min="0.001" max="0.1" step="0.005" value="0.01"
                                   style="width: 100%; margin-bottom: 3px;">
                            <div style="text-align: center; font-size: 10px; color: #999; margin-bottom: 8px;" id="attraction-value">0.01</div>

                            <label style="display: block; margin-bottom: 3px; font-size: 12px; color: #666;">
                                ğŸŒŠ ê°ì‡  (Damping)
                            </label>
                            <input type="range" id="damping-slider" min="0.7" max="0.99" step="0.01" value="0.9"
                                   style="width: 100%; margin-bottom: 3px;">
                            <div style="text-align: center; font-size: 10px; color: #999; margin-bottom: 10px;" id="damping-value">0.90</div>

                            <div style="display: flex; gap: 5px; margin-top: 8px;">
                                <button id="preset-loose" class="main-button" style="flex: 1; font-size: 11px; padding: 6px;">ëŠìŠ¨</button>
                                <button id="preset-normal" class="main-button" style="flex: 1; font-size: 11px; padding: 6px;">ë³´í†µ</button>
                                <button id="preset-tight" class="main-button" style="flex: 1; font-size: 11px; padding: 6px;">ë‹¨ë‹¨</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <label style="display: block; margin-bottom: 5px; font-size: 13px; color: #666;">
                            ğŸ“ ê¸€ì í¬ê¸°
                        </label>
                        <input type="range" id="text-scale-slider" min="0.5" max="2" step="0.1" value="1"
                               style="width: 100%; margin-bottom: 5px;">
                        <div style="text-align: center; font-size: 11px; color: #999;" id="text-scale-value">100%</div>
                    </div>

                    <div class="control-section">
                        <button id="reset-btn" class="main-button">ğŸ”„ ë¦¬ì…‹</button>
                    </div>
                `;

                controlPanel.querySelector('#start-demo-btn').onclick = () => {
                    this.animator.startDemo();
                };

                controlPanel.querySelector('#toggle-physics-btn').onclick = () => {
                    this.renderer.physics.enabled = !this.renderer.physics.enabled;
                    const btn = controlPanel.querySelector('#toggle-physics-btn');
                    btn.textContent = this.renderer.physics.enabled ? 'âš¡ ë¬¼ë¦¬ì—”ì§„: ON' : 'âš¡ ë¬¼ë¦¬ì—”ì§„: OFF';
                    btn.classList.toggle('primary', this.renderer.physics.enabled);
                };

                controlPanel.querySelector('#reset-btn').onclick = () => {
                    this.loadDummyData();
                };

                // ê¸€ì í¬ê¸° ì¡°ì ˆ
                const textScaleSlider = controlPanel.querySelector('#text-scale-slider');
                const textScaleValue = controlPanel.querySelector('#text-scale-value');
                textScaleSlider.oninput = (e) => {
                    const scale = parseFloat(e.target.value);
                    this.renderer.textScale = scale;
                    textScaleValue.textContent = Math.round(scale * 100) + '%';
                    this.renderer.render();
                };

                // ë¬¼ë¦¬ ì—”ì§„ ì„¤ì • íŒ¨ë„ í† ê¸€
                const physicsPanel = controlPanel.querySelector('#physics-controls');
                const togglePhysicsPanelBtn = controlPanel.querySelector('#toggle-physics-panel');
                togglePhysicsPanelBtn.onclick = () => {
                    const isVisible = physicsPanel.style.display !== 'none';
                    physicsPanel.style.display = isVisible ? 'none' : 'block';
                    togglePhysicsPanelBtn.innerHTML = isVisible ? 'âš™ï¸ ë¬¼ë¦¬ ì—”ì§„ ì„¤ì • â–¼' : 'âš™ï¸ ë¬¼ë¦¬ ì—”ì§„ ì„¤ì • â–²';
                };

                // ì¤‘ì‹¬ í˜ ì¡°ì ˆ
                const centerForceSlider = controlPanel.querySelector('#center-force-slider');
                const centerForceValue = controlPanel.querySelector('#center-force-value');
                centerForceSlider.oninput = (e) => {
                    const value = parseFloat(e.target.value);
                    this.renderer.physics.centerPull = value;
                    centerForceValue.textContent = value.toFixed(4);
                };

                // ë°˜ë°œë ¥ ì¡°ì ˆ
                const repulsionSlider = controlPanel.querySelector('#repulsion-slider');
                const repulsionValue = controlPanel.querySelector('#repulsion-value');
                repulsionSlider.oninput = (e) => {
                    const value = parseFloat(e.target.value);
                    this.renderer.physics.repulsion = value;
                    repulsionValue.textContent = value.toString();
                };

                // ë§í¬ ì¸ë ¥ ì¡°ì ˆ
                const attractionSlider = controlPanel.querySelector('#attraction-slider');
                const attractionValue = controlPanel.querySelector('#attraction-value');
                attractionSlider.oninput = (e) => {
                    const value = parseFloat(e.target.value);
                    this.renderer.physics.attraction = value;
                    attractionValue.textContent = value.toFixed(3);
                };

                // ê°ì‡  ì¡°ì ˆ
                const dampingSlider = controlPanel.querySelector('#damping-slider');
                const dampingValue = controlPanel.querySelector('#damping-value');
                dampingSlider.oninput = (e) => {
                    const value = parseFloat(e.target.value);
                    this.renderer.physics.damping = value;
                    dampingValue.textContent = value.toFixed(2);
                };

                // í”„ë¦¬ì…‹ ë²„íŠ¼
                const applyPreset = (preset) => {
                    let centerPull, repulsion, attraction, damping;

                    switch(preset) {
                        case 'loose':
                            centerPull = 0.001;
                            repulsion = 8000;
                            attraction = 0.005;
                            damping = 0.85;
                            break;
                        case 'normal':
                            centerPull = 0.002;
                            repulsion = 5000;
                            attraction = 0.01;
                            damping = 0.9;
                            break;
                        case 'tight':
                            centerPull = 0.005;
                            repulsion = 3000;
                            attraction = 0.03;
                            damping = 0.95;
                            break;
                    }

                    this.renderer.physics.centerPull = centerPull;
                    this.renderer.physics.repulsion = repulsion;
                    this.renderer.physics.attraction = attraction;
                    this.renderer.physics.damping = damping;

                    centerForceSlider.value = centerPull;
                    centerForceValue.textContent = centerPull.toFixed(4);
                    repulsionSlider.value = repulsion;
                    repulsionValue.textContent = repulsion.toString();
                    attractionSlider.value = attraction;
                    attractionValue.textContent = attraction.toFixed(3);
                    dampingSlider.value = damping;
                    dampingValue.textContent = damping.toFixed(2);
                };

                controlPanel.querySelector('#preset-loose').onclick = () => applyPreset('loose');
                controlPanel.querySelector('#preset-normal').onclick = () => applyPreset('normal');
                controlPanel.querySelector('#preset-tight').onclick = () => applyPreset('tight');

                document.body.appendChild(controlPanel);

                // ìƒíƒœ íŒ¨ë„
                const statusPanel = document.createElement('div');
                statusPanel.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 20px;
                    background: rgba(0,0,0,0.8);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 5px;
                    font-family: monospace;
                    font-size: 12px;
                    z-index: 1000;
                `;
                statusPanel.innerHTML = `
                    ğŸ“Š ë…¸ë“œ: 5 | ì—£ì§€: 4<br>
                    ğŸ¬ ì• ë‹ˆë©”ì´ì…˜: ì¤€ë¹„ì™„ë£Œ<br>
                    ğŸš€ ìƒíƒœ: ë°ëª¨ ì‹¤í–‰ ê°€ëŠ¥
                `;
                document.body.appendChild(statusPanel);
            }

            async loadDummyData() {
                try {
                    // graph.jsonì´ ìˆìœ¼ë©´ ë¡œë“œ, ì—†ìœ¼ë©´ ë”ë¯¸ ë°ì´í„° ì‚¬ìš©
                    let graphData;

                    try {
                        const response = await fetch('graph.json');
                        if (response.ok) {
                            graphData = await response.json();
                            console.log('ğŸ“¡ Loaded graph.json from bot');
                        } else {
                            throw new Error('graph.json not found');
                        }
                    } catch (fetchError) {
                        console.log('ğŸ“‹ Using dummy data');
                        graphData = JSON.parse(
                            document.getElementById('dummy-graph-data').textContent
                        );
                    }

                    // ëª¨ë“  ìš”ì†Œ ë‹¤ì‹œ ë³´ì´ê²Œ ì„¤ì •
                    if (graphData.nodes) {
                        // ìµœì‹  ë…¸ë“œ ì°¾ê¸° (metadata.created_at ë˜ëŠ” ID ê¸°ì¤€)
                        const sortedNodes = [...graphData.nodes].sort((a, b) => {
                            const timeA = a.metadata?.created_at || a.id;
                            const timeB = b.metadata?.created_at || b.id;
                            return String(timeB).localeCompare(String(timeA));
                        });

                        // í•˜ëŠ˜ìƒ‰~íŒŒë€ìƒ‰ ê·¸ë¼ë°ì´ì…˜ ìƒ‰ìƒ íŒ”ë ˆíŠ¸
                        const skyBlueColors = [
                            '#0EA5E9', // ì§„í•œ ìŠ¤ì¹´ì´ë¸”ë£¨
                            '#38BDF8', // ë°ì€ ìŠ¤ì¹´ì´ë¸”ë£¨
                            '#60A5FA', // ë°ì€ ë¸”ë£¨
                            '#7DD3FC', // ì—°í•œ ìŠ¤ì¹´ì´ë¸”ë£¨
                            '#BAE6FD', // ì•„ì£¼ ì—°í•œ ìŠ¤ì¹´ì´ë¸”ë£¨
                            '#E0F2FE'  // ê±°ì˜ í°ìƒ‰ì— ê°€ê¹Œìš´ í•˜ëŠ˜ìƒ‰
                        ];

                        // ê° ë…¸ë“œì— ìƒ‰ìƒ í• ë‹¹ (ìµœì‹  -> ì˜¤ë˜ëœ ìˆœ)
                        graphData.nodes.forEach((node, index) => {
                            node.animationVisible = true;

                            // ë…¸ë“œì˜ ë‚˜ì´ ê³„ì‚° (0=ìµœì‹ , 1=ê°€ì¥ ì˜¤ë˜ë¨)
                            const nodeIndex = sortedNodes.findIndex(n => n.id === node.id);
                            const ageRatio = sortedNodes.length > 1
                                ? nodeIndex / (sortedNodes.length - 1)
                                : 0;

                            // ìƒ‰ìƒ ì¸ë±ìŠ¤ ê³„ì‚° (0=ì§„í•œìƒ‰, 5=ì—°í•œìƒ‰)
                            const colorIndex = Math.floor(ageRatio * (skyBlueColors.length - 1));
                            node.color = skyBlueColors[colorIndex];

                            // ìƒìœ„ 20% ë˜ëŠ” ìµœëŒ€ 5ê°œë¥¼ ìµœì‹  ë…¸ë“œë¡œ í‘œì‹œ
                            const recentCount = Math.min(Math.ceil(sortedNodes.length * 0.2), 5);
                            if (nodeIndex < recentCount) {
                                node.isRecent = true;
                            }
                        });
                    }
                    if (graphData.edges) {
                        graphData.edges.forEach(edge => {
                            edge.animationVisible = true;
                        });
                    }

                    this.renderer.updateGraph(graphData);
                    console.log(`âœ… Graph loaded: ${graphData.nodes?.length || 0} nodes, ${graphData.edges?.length || 0} edges`);
                } catch (error) {
                    console.error('Failed to load graph data:', error);
                }
            }
        }

        // ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”
        function initializeApp() {
            try {
                console.log('ğŸ”§ Initializing PT Compensation Wiki (Standalone)...');

                const canvas = document.getElementById('main-canvas');
                if (!canvas) {
                    throw new Error('Canvas element not found');
                }

                const app = new PTCompensationWiki(canvas);
                window.ptWiki = app;

                // ë¡œë”© í™”ë©´ ìˆ¨ê¸°ê¸°
                setTimeout(() => {
                    document.getElementById('loading-screen').style.display = 'none';
                    console.log('ğŸ‰ PT Compensation Wiki initialized successfully!');
                    console.log('ğŸ’¡ Enhanced 5Why animation system ready - click "ë°ëª¨ ì‹œì‘" to experience the improved flowchart visualization!');
                }, 300);

            } catch (error) {
                console.error('Failed to initialize application:', error);
                alert('ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }

        // DOM ë¡œë”© ì™„ë£Œ í›„ ì´ˆê¸°í™”
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }

        console.log('ğŸ“œ Script loaded successfully');
    </script>

    <!-- ë…¸ë“œ ì •ë³´ ì‚¬ì´ë“œíŒ¨ë„ -->
    <div id="node-info-panel" class="node-info-panel">
        <div class="panel-header">
            <h3 id="panel-title">ë…¸ë“œ ì •ë³´</h3>
            <button id="panel-close-btn" class="panel-close-btn">âœ•</button>
        </div>
        <div class="panel-content">
            <div class="node-basic-info">
                <div class="node-icon"></div>
                <div class="node-details">
                    <h4 id="node-label">-</h4>
                    <p id="node-type">-</p>
                </div>
            </div>

            <div class="info-section">
                <h5>ğŸ“‹ ì„¤ëª…</h5>
                <p id="node-description">-</p>
            </div>

            <div class="info-section">
                <h5>ğŸ“Š ë°œìƒë¥ </h5>
                <p id="node-prevalence">-</p>
            </div>

            <div class="info-section">
                <h5>ğŸ”¬ í‰ê°€ ë„êµ¬</h5>
                <ul id="node-assessment-tools"></ul>
            </div>

            <div class="info-section">
                <h5>ğŸ“š ê³¼í•™ì  ê·¼ê±°</h5>
                <p id="node-evidence">-</p>
            </div>

            <div class="info-section">
                <h5>âš¡ ì¤‘ì¬ ë°©ë²•</h5>
                <ul id="node-interventions"></ul>
            </div>

            <div class="info-section">
                <h5>ğŸ”— ê´€ë ¨ ì§ˆí™˜</h5>
                <ul id="node-related-conditions"></ul>
            </div>

            <div class="info-section">
                <h5>ğŸ“– ì°¸ê³ ë¬¸í—Œ</h5>
                <ul id="node-references"></ul>
            </div>

            <div class="why-analysis-section">
                <h5>ğŸ” Why ë¶„ì„</h5>
                <button id="set-as-why0-btn" class="analysis-btn">
                    ì´ ë…¸ë“œë¥¼ ì‹œì‘ì ìœ¼ë¡œ ì„¤ì •
                </button>
                <p class="analysis-hint">
                    ì´ ë…¸ë“œë¥¼ ìƒˆë¡œìš´ Why0 ì§€ì ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ê¹Šì´ ìˆëŠ” ì›ì¸ ë¶„ì„ì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </p>
            </div>
        </div>
    </div>

    <style>
        /* ë…¸ë“œ ì •ë³´ ì‚¬ì´ë“œíŒ¨ë„ ìŠ¤íƒ€ì¼ */
        .node-info-panel {
            position: fixed;
            top: 0;
            right: -400px;
            width: 380px;
            height: 100vh;
            background: white;
            box-shadow: -2px 0 10px rgba(0,0,0,0.2);
            z-index: 2000;
            transition: right 0.3s ease-in-out;
            overflow-y: auto;
            border-left: 3px solid #2196f3;
        }

        .node-info-panel.open {
            right: 0;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .panel-header h3 {
            margin: 0;
            color: #2196f3;
            font-size: 18px;
        }

        .panel-close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        .panel-close-btn:hover {
            background: #e9ecef;
        }

        .panel-content {
            padding: 20px;
        }

        .node-basic-info {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .node-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin-right: 15px;
            background: #2196f3;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }

        .node-details h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 16px;
        }

        .node-details p {
            margin: 0;
            color: #666;
            font-size: 14px;
        }

        .info-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #f0f0f0;
        }

        .info-section:last-of-type {
            border-bottom: none;
        }

        .info-section h5 {
            margin: 0 0 10px 0;
            color: #2196f3;
            font-size: 14px;
            font-weight: 600;
        }

        .info-section p {
            margin: 0;
            color: #333;
            line-height: 1.5;
            font-size: 14px;
        }

        .info-section ul {
            margin: 0;
            padding-left: 20px;
            color: #333;
        }

        .info-section li {
            margin-bottom: 5px;
            font-size: 14px;
            line-height: 1.4;
        }

        .why-analysis-section {
            margin-top: 25px;
            padding: 20px;
            background: #e3f2fd;
            border-radius: 8px;
            border: 1px solid #bbdefb;
        }

        .why-analysis-section h5 {
            margin: 0 0 15px 0;
            color: #1976d2;
            font-size: 15px;
        }

        .analysis-btn {
            width: 100%;
            padding: 12px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 10px;
        }

        .analysis-btn:hover {
            background: #1976d2;
        }

        .analysis-hint {
            margin: 0;
            font-size: 12px;
            color: #1976d2;
            line-height: 1.4;
        }

        /* ìº”ë²„ìŠ¤ ê³µê°„ ì¡°ì • (íŒ¨ë„ ì—´ë¦´ ë•Œ) */
        body.panel-open #main-canvas {
            width: calc(100vw - 380px);
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 1200px) {
            .node-info-panel {
                width: 320px;
                right: -320px;
            }

            body.panel-open #main-canvas {
                width: calc(100vw - 320px);
            }
        }

        @media (max-width: 768px) {
            .node-info-panel {
                width: 100vw;
                right: -100vw;
            }

            body.panel-open #main-canvas {
                display: none;
            }
        }
    </style>
</body>
</html>